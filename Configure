#! /bin/bash
#-----------------------------------------------------------------------
# If these # comments don't work, trim them. Don't worry about any other
# shell scripts, Configure will trim # comments from them for you.
#
# (If you are trying to port this package to a machine without sh,
# I would suggest you have a look at the prototypical config_h.sh file
# and edit it to reflect your system. Some packages may include samples
# of config.h for certain machines, so you might look for one of those.)
#
# Yes, you may rip this off to use in other distribution packages. This
# script belongs to the public domain and cannot be copyrighted.
#
# (Note: this Configure script was generated automatically. Rather than
# working with this copy of Configure, you may wish to get metaconfig.
# The dist-3.0 package (which contains metaconfig) was posted in
# comp.sources.misc and is available on CPAN under authors/id/RAM so
# you may fetch it yourself from your nearest archive site.)
#-----------------------------------------------------------------------

#-----------------------------------------------------------------------
# $Id: Configure,v 1.1 2004-05-03 05:17:48 behdad Exp $
# Generated on Thu Feb 19 19:32:00 CST 2004 [metaconfig 3.0 PL70]
#-----------------------------------------------------------------------

true || exec sh $0 $argv:q

(exit $?0) || exec sh $0 $argv:q

: compute my invocation name
me=$0
case "$0" in
	*/*)
		me=`echo $0 | sed -e 's!.*/\(.*\)!\1!' 2>/dev/null`
		test "$me" || me=$0
	;;
esac

: Proper PATH separator
p_=:
: On OS/2 this directory should exist if this is not floppy only system :-]
if test -d c:/.; then
	p_=\;
	PATH=`cmd /c "echo %PATH%" | tr '\\\\' / `
	OS2_SHELL=`cmd /c "echo %OS2_SHELL%" | tr '\\\\' / | tr '[A-Z]' '[a-z]'`
fi

: Proper PATH setting
paths='/bin /usr/bin /usr/local/bin /usr/ucb /usr/local /usr/lbin'
paths="$paths /opt/bin /opt/local/bin /opt/local /opt/lbin"
paths="$paths /usr/5bin /etc /usr/gnu/bin /usr/new /usr/new/bin /usr/nbin"
paths="$paths /opt/gnu/bin /opt/new /opt/new/bin /opt/nbin"
paths="$paths /sys5.3/bin /sys5.3/usr/bin /bsd4.3/bin /bsd4.3/usr/ucb"
paths="$paths /bsd4.3/usr/bin /usr/bsd /bsd43/bin /usr/ccs/bin"
paths="$paths /etc /usr/lib /usr/ucblib /lib /usr/ccs/lib"
paths="$paths /sbin /usr/sbin /usr/libexec"

for p in $paths
do
	case "$p_$PATH$p_" in *$p_$p$p_*) ;;
		*) test -d $p && PATH=$PATH$p_$p ;;
	esac
done

PATH=.$p_$PATH
export PATH

: shall we be using ksh?
inksh=''
needksh=''
avoidksh=''
newsh=/bin/ksh
changesh=''
if (PATH=.; alias -x) >/dev/null 2>&1; then
		inksh=true
fi
if test -f /hp-ux -a -f /bin/ksh; then
	needksh='to avoid sh bug in "here document" expansion'
fi
if test -d /usr/lpp -a -f /usr/bin/bsh -a -f /usr/bin/uname; then
	if test X`/usr/bin/uname -v` = X4; then
		avoidksh="to avoid AIX 4's /bin/sh"
		newsh=/usr/bin/bsh
	fi
fi
case "$inksh/$needksh" in
	[a-z]*)
		unset ENV
		changesh=true
		reason="$needksh"
	;;
esac

case "$inksh/$avoidksh" in
	true/[a-z]*)
			changesh=true
			reason="$avoidksh"
	;;
esac
case "$inksh/$needksh-$avoidksh-" in
	true/--)
		cat <<EOM

(I see you are using the Korn shell.  Some ksh's blow up on $me,
mainly on older exotic systems.  If yours does, try the Bourne shell instead.)

EOM
	;;
esac

case "$changesh" in
	true)
		echo "(Feeding myself to $newsh $reason.)"
		case "$0" in Configure|*/Configure) exec $newsh $0 "$@";;
			*) exec $newsh Configure "$@";;
		esac
	;;
esac

: Configure runs within the UU subdirectory
test -d UU || mkdir UU
unset CDPATH
cd UU && rm -f ./*

d_bsd=''
d_xenix=''
Mcc=''
ar=''
awk=''
bash=''
bison=''
byacc=''
cat=''
chgrp=''
chmod=''
chown=''
comm=''
compress=''
cp=''
cpio=''
cpp=''
csh=''
date=''
echo=''
egrep=''
emacs=''
expr=''
find=''
flex=''
gcc=''
grep=''
gzip=''
inews=''
ksh=''
less=''
line=''
lint=''
ln=''
lp=''
lpr=''
ls=''
mail=''
mailx=''
make=''
mkdir=''
more=''
mv=''
nroff=''
perl=''
pg=''
pmake=''
pr=''
rm=''
rmail=''
sed=''
sendmail=''
shar=''
sleep=''
smail=''
sort=''
submit=''
tail=''
tar=''
tbl=''
test=''
touch=''
tr=''
troff=''
uname=''
uniq=''
uuname=''
vi=''
zcat=''
zip=''
hint=''
myuname=''
osname=''
osvers=''
Author=''
Date=''
Header=''
Id=''
Locker=''
Log=''
RCSfile=''
Revision=''
Source=''
State=''
archobjs=''
firstmakefile=''
bin=''
binexp=''
installbin=''
cc=''
gccversion=''
ccflags=''
cppflags=''
ldflags=''
lkflags=''
locincpth=''
optimize=''
cf_by=''
cf_time=''
contains=''
cppfilecom=''
cppstdinflags=''
d_cppcanstdin=''
d_cppignhdrs=''
cpplast=''
cppminus=''
cpprun=''
cppstdin=''
d_access=''
d_attribut=''
d_const=''
d_flexfnam=''
d_gnulibc=''
d_link=''
d_open3=''
d_portable=''
d_index=''
d_strchr=''
d_strftime=''
d_strstr=''
d_symlink=''
d_time=''
timetype=''
d_voidsig=''
signal_t=''
d_volatile=''
h_fcntl=''
h_sysfile=''
i_fcntl=''
i_stddef=''
i_stdlib=''
i_string=''
strings=''
i_sysfile=''
i_systypes=''
i_systime=''
i_systimek=''
i_time=''
timeincl=''
i_unistd=''
i_stdarg=''
i_varargs=''
i_varhdr=''
lex=''
lexflags=''
libc=''
glibpth=''
libpth=''
loclibpth=''
plibpth=''
xlibpth=''
libs=''
libyacc=''
lns=''
installmansrc=''
manext=''
mansrc=''
mansrcexp=''
mkdep=''
c=''
n=''
package=''
spackage=''
prefix=''
prefixexp=''
installprivlib=''
privlib=''
privlibexp=''
prototype=''
sh=''
so=''
sharpbang=''
shsharp=''
spitshell=''
src=''
startsh=''
sysman=''
nm_opt=''
nm_so_opt=''
runnm=''
usenm=''
incpath=''
mips_type=''
usrinc=''
vaproto=''
defvoidused=''
voidflags=''
warnflags=''
yacc=''
yaccflags=''
CONFIG=''

define='define'
undef='undef'
smallmach='pdp11 i8086 z8000 i80286 iAPX286'
rmlist=''

: No trailing extension on UNIX executables
_exe='' 
: Extra object files, if any, needed on this platform.
archobjs=''
gccversion=''
: Possible local include directories to search.
: Set locincpth to "" in a hint file to defeat local include searches.
locincpth="/usr/local/include /opt/local/include /usr/gnu/include"
locincpth="$locincpth /opt/gnu/include /usr/GNU/include /opt/GNU/include"
:
: no include file wanted by default
inclwanted=''

i_sysselct=''
: change the next line if compiling for Xenix/286 on Xenix/386
xlibpth='/usr/lib/386 /lib/386'

: Possible local library directories to search.
loclibpth="/usr/local/lib /opt/local/lib /usr/gnu/lib"
loclibpth="$loclibpth /opt/gnu/lib /usr/GNU/lib /opt/GNU/lib"

: general looking path for locating libraries
glibpth="/shlib /usr/shlib /lib/pa1.1 /usr/lib/large"
glibpth="$glibpth /lib /usr/lib $xlibpth"
glibpth="$glibpth /lib/large /usr/lib/small /lib/small"
glibpth="$glibpth /usr/ccs/lib /usr/ucblib /usr/local/lib"

: Private path used by Configure to find libraries.  Its value
: is prepended to libpth. This variable takes care of special
: machines, Usually, it should be empty.
plibpth=''

: default library list
libswanted=''
large=''
: full support for void wanted by default
defvoidused=15


: Find the basic shell for Bourne shell scripts
case "$sh" in
	'')
		case "$SYSTYPE" in *bsd*|sys5*) xxx="/$SYSTYPE/bin/sh";;
			*) xxx='/bin/sh';;
		esac

		if test -f "$xxx"; then
			sh="$xxx"
		else

		: Build up a list and do a single loop so we can 'break' out.
		pth=`echo $PATH | sed -e "s/$p_/ /g"`
		for xxx in sh bash ksh pdksh ash; do
			for p in $pth; do
				try="$try ${p}/${xxx}"
			done
		done
		for xxx in $try; do
			if test -f "$xxx"; then
				sh="$xxx";
				break
			elif test -f "$xxx.exe"; then
				sh="$xxx";
				break
			fi
		done
	fi
	;;
esac

case "$sh" in
	'')	cat <<EOM >&2
$me:  Fatal Error:  I can't find a Bourne Shell anywhere.  

Usually it's in /bin/sh.  How did you even get this far?
Please contact me (Manoj Srivastava) at srivasta@debian.org and 
we'll try to straighten this all out.
EOM

		exit 1
	;;
esac

: see if sh knows # comments
if `$sh -c '#' >/dev/null 2>&1`; then

	shsharp=true
	spitshell=cat
	xcat=/bin/cat
	test -f $xcat || xcat=/usr/bin/cat
	echo "#!$xcat" >try
	chmod +x try
	./try > today

	if test -s today; then
		sharpbang='#!'
	else
		echo "#! $xcat" > try
		chmod +x try
		./try > today
		if test -s today; then
			sharpbang='#! '
		else
			sharpbang=': use '
		fi
	fi
else
	echo " "
	echo "Your $sh doesn't grok # comments--I will strip them later on."
	shsharp=false
	cd ..
	echo "exec grep -v '^[ 	]*#'" >spitshell
	chmod +x spitshell
	spitshell=`pwd`/spitshell
	cd UU
	echo "I presume that if # doesn't work, #! won't work either!"
	sharpbang=': use '
fi
rm -f try today

: figure out how to guarantee sh startup
case "$startsh" in
	'') startsh=${sharpbang}${sh} ;;
	*)
esac

cat >try <<EOSS
$startsh
set abc
test "$?abc" != 1
EOSS

chmod +x try
if ./try; then
	: echo "Yup, it does."
else
	echo "Hmm... '$startsh' does not guarantee sh startup..."
	echo "You may have to fix up the shell scripts to make sure $sh runs them."
fi
rm -f try

: produce awk script to parse command line options
cat >options.awk <<'EOF'
BEGIN {
	optstr = "dD:eEf:hKOrsSU:V";	# getopt-style specification

	len = length(optstr);
	for (i = 1; i <= len; i++) {
		c = substr(optstr, i, 1);
		if (i < len) a = substr(optstr, i + 1, 1); else a = "";
		if (a == ":") {
			arg[c] = 1;
			i++;
		}
		opt[c] = 1;
	}
}
{
	expect = 0;
	str = $0;
	if (substr(str, 1, 1) != "-") {
		printf("'%s'\n", str);
		next;
	}
	len = length($0);
	for (i = 2; i <= len; i++) {
		c = substr(str, i, 1);
		if (!opt[c]) {
			printf("-%s\n", substr(str, i));
			next;
		}
		printf("-%s\n", c);
		if (arg[c]) {
			if (i < len)
				printf("'%s'\n", substr(str, i + 1));
			else
				expect = 1;
			next;
		}
	}
}
END {
	if (expect)
		print "?";
}
EOF

: process the command line options
set X `for arg in "$@"; do echo "X$arg"; done |
	sed -e s/X// | awk -f options.awk`
eval "set $*"
shift
rm -f options.awk

: set up default values
fastread=''
reuseval=false
config_sh=''
alldone=''
error=''
silent=''
extractsh=''
override=''
knowitall=''
rm -f optdef.sh
cat >optdef.sh <<EOS
$startsh
EOS


: option parsing
while test $# -gt 0; do
	case "$1" in
		-d) shift; fastread=yes;;
		-e) shift; alldone=cont;;
		-f)
			shift
			cd ..
			if test -r "$1"; then
				config_sh="$1"
			else
				echo "$me: cannot read config file $1." >&2
				error=true
			fi
			cd UU
			shift;;
		-h) shift; error=true;;
		-r) shift; reuseval=true;;
		-s) shift; silent=true; realsilent=true;;
		-E) shift; alldone=exit;;
		-K) shift; knowitall=true;;
		-O) shift; override=true;;
		-S) shift; silent=true; extractsh=true;;
		-D)
			shift
			case "$1" in
				*=)
					echo "$me: use '-U symbol=', not '-D symbol='." >&2
					echo "$me: ignoring -D $1" >&2
				;;
				*=*) echo "$1" | sed -e "s/'/'\"'\"'/g" -e "s/=\(.*\)/='\1'/" >> optdef.sh;;
				*) echo "$1='define'" >> optdef.sh;;
			esac
			shift
		;;
	-U)
		shift
		case "$1" in
			*=) echo "$1" >> optdef.sh;;
			*=*)
				echo "$me: use '-D symbol=val', not '-U symbol=val'." >&2
				echo "$me: ignoring -U $1" >&2
			;;
			*)
				echo "$1='undef'" >> optdef.sh;;
				esac
				shift
			;;
	-V) 	echo "$me generated by metaconfig 3.0 PL70." >&2
		exit 0;;
	--) 	break;;
	-*) 	echo "$me: unknown option $1" >&2; shift; error=true;;
	*) 	break;;
	esac
done

case "$error" in
true)
	cat >&2 <<EOM
Usage: $me [-dehrsEKOSV] [-f config.sh] [-D symbol] [-D symbol=value]
                 [-U symbol] [-U symbol=]
  -d : use defaults for all answers.
  -e : go on without questioning past the production of config.sh.
  -f : specify an alternate default configuration file.
  -h : print this help message and exit (with an error status).
  -r : reuse C symbols value if possible (skips costly nm extraction).
  -s : silent mode, only echoes questions and essential information.
  -D : define symbol to have some value:
         -D symbol         symbol gets the value 'define'
         -D symbol=value   symbol gets the value 'value'
  -E : stop at the end of questions, after having produced config.sh.
  -K : do not use unless you know what you are doing.
  -O : let -D and -U override definitions from loaded configuration file.
  -S : perform variable substitutions on all .sh files (can mix with -f)
  -U : undefine symbol:
         -U symbol    symbol gets the value 'undef'
         -U symbol=   symbol gets completely empty
  -V : print version number and exit (with a zero status).
EOM
	exit 1
	;;
esac

: Sanity checks
case "$fastread$alldone" in
yescont|yesexit) ;;
*)
	if test ! -t 0; then
		echo "Say 'sh Configure', not 'sh <Configure'"
		exit 1
	fi
	;;
esac

exec 4>&1
case "$silent" in
	true) exec 1>/dev/null;;
esac

: run the defines and the undefines, if any, but leave the file out there...
touch optdef.sh
. ./optdef.sh

: set package name
package=c2man
first=`echo $package | sed -e 's/^\(.\).*/\1/'`
last=`echo $package | sed -e 's/^.\(.*\)/\1/'`
case "`echo AbyZ | tr '[:lower:]' '[:upper:]' 2>/dev/null`" in ABYZ) spackage=`echo $first | tr '[:lower:]' '[:upper:]'`$last;;
	*) spackage=`echo $first | tr '[a-z]' '[A-Z]'`$last;;
esac

: Some greps do not return status, grrr.
echo "grimblepritz" >grimble
if grep blurfldyick grimble >/dev/null 2>&1 ; then
	contains=contains
elif grep grimblepritz grimble >/dev/null 2>&1 ; then
	contains=grep
else
	contains=contains
fi
rm -f grimble
: the following should work in any shell
case "$contains" in
	contains*)
			echo " "
			echo "AGH!  Grep doesn't return a status.  Attempting remedial action."
			cat >contains <<'EOSS'
				grep "$1" "$2" >.greptmp && cat .greptmp && test -s .greptmp
EOSS
			chmod +x contains
esac

: first determine how to suppress newline on echo command
echo " "
echo "Checking echo to see how to suppress newlines..."
(echo "hi there\c" ; echo " ") >.echotmp
if $contains c .echotmp >/dev/null 2>&1 ; then
	echo "...using -n."
	n='-n'
	c=''
else
	cat <<'EOM'
...using \c
EOM
	n=''
	c='\c'
fi
echo $n "The star should be here-->$c"
echo '*'
rm -f .echotmp

: compute the number of columns on the terminal for proper question formatting
case "$COLUMNS" in
	'') COLUMNS='80';;
esac

: set up the echo used in my read
myecho="case \"\$xxxm\" in '') echo $n \"\$rp $c\" >&4;;
	*) case \"\$rp\" in
	'') echo $n \"[\$xxxm] $c\";;
	*)
		if test \`echo \"\$rp [\$xxxm]  \" | wc -c\` -ge $COLUMNS; then
			echo \"\$rp\" >&4
			echo $n \"[\$xxxm] $c\" >&4
		else
			echo $n \"\$rp [\$xxxm] $c\" >&4
		fi
		;;
	esac;;
esac"

: now set up to do reads with possible shell escape and default assignment
cat <<EOSC >myread
$startsh
xxxm=\$dflt
$myecho
ans='!'
case "\$fastread" in
	yes) case "\$dflt" in
		'') ;;
		*) ans='';

		case "\$silent-\$rp" in
			true-) ;;
			*) echo " " >&4;;
		esac;;
	esac;;

	*) case "\$silent" in
		true) case "\$rp" in
			'') ans='';;
		esac;;
	esac;;
esac
while expr "X\$ans" : "X!" >/dev/null; do
	read answ
	set x \$xxxm
	shift
	aok=''; eval "ans=\\"\$answ\\"" && aok=y
	case  "\$answ" in
	"!")
		sh 1>&4
		echo " "
		$myecho
		;;
	!*)
		set x \`expr "X\$ans" : "X!\(.*\)\$"\`
		shift
		sh 1>&4 -c "\$*"
		echo " "
		$myecho
		;;
	"\$ans")
		case "\$ans" in
		\\&*)
			set x \`expr "X\$ans" : "X&\(.*\)\$"\`
			shift
			case "\$1" in
			-d)
				fastread=yes
				echo "(OK, I'll run with -d after this question.)" >&4
				;;
			-*)
				echo "*** Sorry, \$1 not supported yet." >&4
				;;
			esac
			$myecho
			ans=!
			;;
		esac;;
	*)
		case "\$aok" in
		y)
			echo "*** Substitution done -- please confirm."
			xxxm="\$ans"
			ans=\`echo $n "\$ans$c" | tr '\012' ' '\`
			xxxm="\$ans"
			ans=!
			;;
		*)
			echo "*** Error -- try again."
			ans=!
			;;
		esac
		$myecho
		;;
	esac
	case "\$ans\$xxxm\$nostick" in
	'')
		ans=!
		$myecho
		;;
	esac
done
case "\$ans" in
'') ans="\$xxxm";;
esac
EOSC

: Find the path to the source tree
case "$src" in
'') src=`echo $0 | sed -e 's%/[^/][^/]*$%%'`;;
esac
case "$src" in
'')
	src=.
	rsrc=..
	;;
/*) rsrc="$src/..";;
*) rsrc="../$src";;
esac
if test -f $rsrc/Configure && \
	$contains "^package=$package" $rsrc/Configure >/dev/null 2>&1
then
   : found it, so we are ok.
else
	rsrc=''
	for src in . .. ../.. ../../.. ../../../..; do
		if test -f ../$src/Configure && \
			$contains "^package=$package" ../$src/Configure >/dev/null 2>&1
		then
			rsrc=../$src
			break
		fi
	done
fi
case "$rsrc" in
'')
	echo " "
	dflt=
	rp="Directory where sources for $package are located?"
	. ./myread
	src="$ans"
	rsrc="$src"
	if test -f $rsrc/Configure && \
		$contains "^package=$package" $rsrc/Configure >/dev/null 2>&1
	then
		echo "Ok, I've found them under $src"
	else
		echo "Sorry, I can't seem to be able to locate $package sources." >&4
		exit 1
	fi
	;;
../.) ;;
*)
	echo " "
	echo "Sources for $package found in $src" >&4
	;;
esac

: script used to extract .sh files with variable substitutions
cat >extract <<'EOS'
CONFIG=true
echo "Doing variable substitutions on .sh files..."
if test -f $src/MANIFEST; then
	set x `awk '{print $1}' <$src/MANIFEST | grep '\.sh'`
else
	echo "(Looking for .sh files under the source directory.)"
	set x `(cd $src; find . -name "*.sh" -print)`
fi
shift
case $# in
	0) set x `(cd $src; echo *.sh)`; shift;;
esac
if test ! -f $src/$1; then
	shift
fi
mkdir_p='
name=$1;
create="";
while test $name; do
	if test ! -d "$name"; then
		create="$name $create";
		name=`echo $name | sed -e "s|^[^/]*$||"`;
		name=`echo $name | sed -e "s|\(.*\)/.*|\1|"`;
	else
		name="";
	fi;
done;
for file in $create; do
	mkdir $file;
done
'
for file in $*; do
	case "$src" in
	".")
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			(cd $dir && . ./$file)
			;;
		*)
			. ./$file
			;;
		esac
		;;
	*)
		case "$file" in
		*/*)
			dir=`expr X$file : 'X\(.*\)/'`
			file=`expr X$file : 'X.*/\(.*\)'`
			(set x $dir; shift; eval $mkdir_p)
			sh <$src/$dir/$file
			;;
		*)
			sh <$src/$file
			;;
		esac
		;;
	esac
done
if test -f $src/config_h.sh; then
	if test ! -f config.h; then
	: oops, they left it out of MANIFEST, probably, so do it anyway.
	. $src/config_h.sh
	fi
fi
EOS

: extract files and exit if asked to do so
case "$extractsh" in
true)
	case "$realsilent" in
		true) ;;
		*) exec 1>&4;;
	esac
	case "$config_sh" in
		'') config_sh='config.sh'; config="$rsrc/config.sh";;
		/*) config="$config_sh";;
		*) config="$rsrc/$config_sh";;
	esac

	echo " "
	echo "Fetching answers from $config_sh..."
	. $config
	test "$override" && . ./optdef.sh
	echo " "
	cd ..
	. UU/extract
	rm -rf UU
	echo "Done."
	exit 0
	;;
esac

: Eunice requires " " instead of "", can you believe it
echo " "
: Here we go...
echo "Beginning of configuration questions for $package."

trap 'echo " "; test -d ../UU && rm -rf X $rmlist; exit 1' 1 2 3 15

: Now test for existence of everything in MANIFEST
echo " "
if test -f $rsrc/MANIFEST; then
	echo "First let's make sure your kit is complete.  Checking..." >&4
	awk '$1 !~ /PACK[A-Z]+/ {print $1}' $rsrc/MANIFEST | split -l 50
	rm -f missing
	tmppwd=`pwd`
	for filelist in x??; do
		(cd $rsrc; ls `cat $tmppwd/$filelist` >/dev/null 2>>$tmppwd/missing)
	done
	if test -s missing; then
		cat missing >&4
		cat >&4 <<'EOM'

THIS PACKAGE SEEMS TO BE INCOMPLETE.

You have the option of continuing the configuration process, despite the
distinct possibility that your kit is damaged, by typing 'y'es.  If you
do, don't blame me if something goes wrong.  I advise you to type 'n'o
and contact the author (srivasta@debian.org).

EOM
		echo $n "Continue? [n] $c" >&4
		read ans
		case "$ans" in
		y*)
			echo "Continuing..." >&4
			rm -f missing
			;;
		*)
			echo "ABORTING..." >&4
			kill $$
			;;
		esac
	else
		echo "Looks good..."
	fi
else
	echo "There is no MANIFEST file.  I hope your kit is complete !"
fi
rm -f missing x??

: create .config dir to save info across Configure sessions
test -d ../.config || mkdir ../.config
cat >../.config/README <<EOF
This directory created by Configure to save information that should
persist across sessions for $package.

You may safely delete it if you wish.
EOF

: general instructions
needman=true
firsttime=true
user=`(logname) 2>/dev/null`
case "$user" in
	'') user=`whoami 2>&1`;;
esac

if $contains "^$user\$" ../.config/instruct >/dev/null 2>&1; then
	firsttime=false
	echo " "
	rp='Would you like to see the instructions?'
	dflt=n
	. ./myread
	case "$ans" in
		[yY]*) ;;
		*) needman=false;;
	esac
fi

if $needman; then
	cat <<EOH
 
This installation shell script will examine your system and ask you questions
to determine how the c2man package should be installed. If you get
stuck on a question, you may use a ! shell escape to start a subshell or
execute a command.  Many of the questions will have default answers in square
brackets; typing carriage return will give you the default.

On some of the questions which ask for file or directory names you are allowed
to use the ~name construct to specify the login directory belonging to "name",
even if you don't have a shell which knows about that.  Questions where this is
allowed will be marked "(~name ok)".

EOH
	rp=''
	dflt='Type carriage return to continue'
	. ./myread
	cat <<'EOH'

The prompter used in this script allows you to use shell variables and
backticks in your answers.  You may use $1, $2, etc...  to refer to the words
in the default answer, as if the default line was a set of arguments given to a
script shell.  This means you may also use $* to repeat the whole default line,
so you do not have to re-type everything to add something to the default.

Everytime there is a substitution, you will have to confirm.  If there is an
error (e.g. an unmatched backtick), the default answer will remain unchanged
and you will be prompted again.

If you are in a hurry, you may run 'Configure -d'.  This will bypass nearly all
the questions and use the computed defaults (or the previous answers if there
was already a config.sh file). Type 'Configure -h' for a list of options.
You may also start interactively and then answer '& -d' at any prompt to turn
on the non-interactive behaviour for the remaining of the execution.

EOH
	. ./myread
	cat <<EOH

Much effort has been expended to ensure that this shell script will run on any
Unix system.  If despite that it blows up on yours, your best bet is to edit
Configure and run it again.  If you can't run Configure for some reason,
you'll have to generate a config.sh file by hand.  Whatever problems you
have, let me (srivasta@debian.org) know how I blew it.

This installation script affects things in two ways:

1) it may do direct variable substitutions on some of the files included
   in this kit.
2) it builds a config.h file for inclusion in C programs.  You may edit
   any of these files as the need arises after running this script.

If you make a mistake on a question, there is no easy way to back up to it
currently.  The easiest thing to do is to edit config.sh and rerun all the SH
files.  Configure will offer to let you do this before it runs the SH files.

EOH
	dflt='Type carriage return to continue'
	. ./myread
	case "$firsttime" in
		true) echo $user >>../.config/instruct;;
	esac
fi

: find out where common programs are
echo " "
echo "Locating common programs..." >&4
cat <<EOSC >loc
$startsh

case \$# in
	0) exit 1;;
esac

thing=\$1
shift
dflt=\$1
shift
for dir in \$*; do
	case "\$thing" in
		.)
			if test -d \$dir/\$thing; then
				echo \$dir
				exit 0
			fi
			;;
		*)
			for thisthing in \$dir/\$thing; do
			: just loop through to pick last item
			done

			if test -f \$thisthing; then
				echo \$thisthing
				exit 0
			fi
			;;
	esac
done
echo \$dflt
exit 1
EOSC
chmod +x loc
loclist="
awk
cat
cp
echo
expr
grep
mv
rm
sed
sort
touch
tr
uniq
"
trylist="
Mcc
bison
byacc
cpp
date
flex
ln
nroff
test
uname
"
pth=`echo $PATH | sed -e "s/$p_/ /g"`
pth="$pth /lib /usr/lib"
for file in $loclist; do
	eval xxx=\$$file
	case "$xxx" in
		/*|?:[\\/]*)
				if test -f "$xxx"; then
					: ok
				else
					echo "WARNING: no $xxx -- ignoring your setting for $file." >&4
					xxx=`./loc $file $file $pth`
				fi
				;;

		'')		 xxx=`./loc $file $file $pth`;;
		*) xxx=`./loc $xxx $xxx $pth`;;
	esac

	eval $file=$xxx
	eval _$file=$xxx

	case "$xxx" in
		/*)
			echo $file is in $xxx.
			;;
		?:[\\/]*)
			echo $file is in $xxx.
		;;

		*)
			echo "I don't know where '$file' is, and my life depends on it." >&4
			echo "Go find a public domain implementation or fix your PATH setting!" >&4
			exit 1
		;;
	esac
done
echo " "
echo "Don't worry if any of the following aren't found..."
say=offhand
for file in $trylist; do
	eval xxx=\$$file
	case "$xxx" in
		/*|?:[\\/]*)
				if test -f "$xxx"; then
					: ok
				else
					echo "WARNING: no $xxx -- ignoring your setting for $file." >&4
					xxx=`./loc $file $file $pth`
				fi
				;;

		'') 		xxx=`./loc $file $file $pth`;;
		*)		 xxx=`./loc $xxx $xxx $pth`;;
	esac
	eval $file=$xxx
	eval _$file=$xxx
	case "$xxx" in
		/*)
			echo $file is in $xxx.
			;;
		?:[\\/]*)
			echo $file is in $xxx.
			;;
		*)
			echo "I don't see $file out there, $say."
			say=either
		;;
	esac
done
case "$egrep" in
egrep)
	echo "Substituting grep for egrep."
	egrep=$grep
	;;
esac
case "$ln" in
ln)
	echo "Substituting cp for ln."
	ln=$cp
	;;
esac
case "$test" in
test)
	echo "Hopefully test is built into your sh."
	;;
*)
	if `sh -c "PATH= test true" >/dev/null 2>&1`; then
		echo "Using the test built into your sh."
		test=test
		_test=test
	fi
	;;
esac
case "$echo" in
	echo)
		echo "Hopefully echo is built into your sh."
		;;
	'') 	;;
	*)
		echo " "
		echo "Checking compatibility between $echo and builtin echo (if any)..." >&4
		$echo $n "hi there$c" >foo1
		echo $n "hi there$c" >foo2
		if cmp foo1 foo2 >/dev/null 2>&1; then
			echo "They are compatible.  In fact, they may be identical."
		else
			case "$n" in
				'-n')	 n='' c='\c';;
				*)	 n='-n' c='';;
			esac
			cat <<FOO

They are not compatible!  You are probably running ksh on a non-USG system.
I'll have to use $echo instead of the builtin, since Bourne shell doesn't
have echo built in and we may have to run some Bourne shell scripts.  That
means I'll have to use '$n$c' to suppress newlines now.  Life is ridiculous.

FOO
			$echo $n "The star should be here-->$c"
			$echo "*"
		fi
		$rm -f foo1 foo2
		;;
esac

: determine whether symbolic links are supported
echo " "
$touch blurfl
if $ln -s blurfl sym > /dev/null 2>&1 ; then
	echo "Symbolic links are supported." >&4
	lns="$ln -s"
else
	echo "Symbolic links are NOT supported." >&4
	lns="$ln"
fi
$rm -f blurfl sym

: see whether [:lower:] and [:upper:] are supported character classes
echo " "
up='[A-Z]'
low='[a-z]'
case "`echo AbyZ | $tr '[:lower:]' '[:upper:]' 2>/dev/null`" in
	ABYZ)
		echo "Good, your tr supports [:lower:] and [:upper:] to convert case." >&4
		up='[:upper:]'
		low='[:lower:]'
	;;

	*)
		echo "Your tr only supports [a-z] and [A-Z] to convert case." >&4
	;;
esac

: set up the translation script tr, must be called with ./tr of course
cat >tr <<EOSC
$startsh
case "\$1\$2" in
	'[A-Z][a-z]') exec $tr '$up' '$low';;
	'[a-z][A-Z]') exec $tr '$low' '$up';;
esac

exec $tr "\$@"
EOSC
chmod +x tr

: Try to determine whether config.sh was made on this system
case "$config_sh" in
	'')
		myuname=`( ($uname -a) 2>/dev/null || hostname) 2>&1`
		myuname=`echo $myuname | $sed -e 's/^[^=]*=//' -e 's/\///g' | \
		./tr '[A-Z]' '[a-z]' | tr '\012' ' '`
		newmyuname="$myuname"
		dflt=n

		case "$knowitall" in
			'')
				if test -f ../config.sh; then
					if $contains myuname= ../config.sh >/dev/null 2>&1; then
						eval "`grep myuname= ../config.sh`"
					fi

					if test "X$myuname" = "X$newmyuname"; then
						dflt=y
					fi
				fi
				;;

			*) dflt=y;;
		esac

		: Get old answers, if there is a config file out there
		hint=default
		hintfile=''
		if test -f ../config.sh; then
			echo " "
			rp="I see a config.sh file.  Shall I use it to set the defaults?"
			. ./myread

			case "$ans" in
				n*|N*)	echo "OK, I'll ignore it.";;
				*)  	echo "Fetching default answers from your old config.sh file..." >&4
					tmp_n="$n"
					tmp_c="$c"
					. ../config.sh
					cp ../config.sh .
					n="$tmp_n"
					c="$tmp_c"
					hint=previous
					;;
				esac
			fi
	;;

	*)
		echo " "
		echo "Fetching default answers from $config_sh..." >&4
		tmp_n="$n"
		tmp_c="$c"
		cd ..
		cp $config_sh config.sh 2>/dev/null
		chmod +w config.sh
		. ./config.sh
		cd UU
		cp ../config.sh .
		n="$tmp_n"
		c="$tmp_c"
		hint=previous
	;;
esac

test "$override" && . ./optdef.sh
myuname="$newmyuname"

: Restore computed paths
for file in $loclist $trylist; do
	eval $file="\$_$file"
done

: who configured the system
cf_time=`$date 2>&1`
cf_by=`(logname) 2>/dev/null`
case "$cf_by" in
	"")
		cf_by=`(whoami) 2>/dev/null`
		case "$cf_by" in
			"") cf_by=unknown ;;
		esac ;;
esac

: decide how portable to be
case "$d_portable" in
	"$define")	dflt=y;;
	*)		dflt=n;;
esac
$cat <<'EOH'
 
I can set things up so that your shell scripts and binaries are more portable,
at what may be a noticable cost in performance.  In particular, if you
ask to be portable, the following happens:

     1) Shell scripts will rely on the PATH variable rather than using
	the paths derived above.
     2) ~username interpretations will be done at run time rather than
	by Configure.

EOH
rp="Do you expect to run these scripts and binaries on multiple machines?"
. ./myread
case "$ans" in
	y*) d_portable="$define"
	;;
	*)  d_portable="$undef" ;;
esac

: set up shell script to do ~ expansion
cat >filexp <<EOSS
$startsh
: expand filename
case "\$1" in
	 ~/*|~)
			echo \$1 | $sed "s|~|\${HOME-\$LOGDIR}|"
			;;
 	~*)
			if $test -f /bin/csh; then
				/bin/csh -f -c "glob \$1"
				failed=\$?
				echo ""
				exit \$failed
			else
				name=\`$expr x\$1 : '..\([^/]*\)'\`
				dir=\`$sed -n -e "/^\${name}:/{s/^[^:]*:[^:]*:[^:]*:[^:]*:[^:]*:\([^:]*\).*"'\$'"/\1/" -e p -e q -e '}' </etc/passwd\`

				if $test ! -d "\$dir"; then
					me=\`basename \$0\`

					echo "\$me: can't locate home directory for: \$name" >&2
					exit 1
				fi

			case "\$1" in
				*/*)
					echo \$dir/\`$expr x\$1 : '..[^/]*/\(.*\)'\`
				;;

				*)
					echo \$dir
				;;
			esac
		fi
	;;

	*)
		echo \$1
	;;
esac

EOSS
chmod +x filexp

: now set up to get a file name
cat <<EOS >getfile
$startsh
EOS
cat <<'EOSC' >>getfile
tilde=''
fullpath=''
already=''
skip=''
none_ok=''
exp_file=''
nopath_ok=''
orig_rp="$rp"
orig_dflt="$dflt"

case "$fn" in
	*\(*)
		expr $fn : '.*(\(.*\)).*' | tr ',' '\012' >getfile.ok
		fn=`echo $fn | sed 's/(.*)//'`
	;;
esac

case "$fn" in
	*:*)
		loc_file=`expr $fn : '.*:\(.*\)'`
		fn=`expr $fn : '\(.*\):.*'`
	;;
esac

case "$fn" in
		*~*) tilde=true;;
esac

case "$fn" in
		*/*) fullpath=true;;
esac

case "$fn" in
		*+*) skip=true;;
esac

case "$fn" in
		*n*) none_ok=true;;
esac
case "$fn" in
		*e*) exp_file=true;;
esac

case "$fn" in
	*p*) nopath_ok=true;;
esac

case "$fn" in
	*f*) 	type='File';;
	*d*) 	type='Directory';;
	*l*) 	type='Locate';;
esac

what="$type"
case "$what" in
	Locate) what='File';;
esac

case "$exp_file" in
'')
	case "$d_portable" in
		"$define")	 ;;
		*) 		exp_file=true;;
	esac
	;;
esac

cd ..
while test "$type"; do
	redo=''
	rp="$orig_rp"
	dflt="$orig_dflt"

	case "$tilde" in
		true) rp="$rp (~name ok)";;
	esac

	. UU/myread
	if test -f UU/getfile.ok && \
		$contains "^$ans\$" UU/getfile.ok >/dev/null 2>&1
	then
		value="$ans"
		ansexp="$ans"
		break
	fi
	case "$ans" in
		none)
			value=''
			ansexp=''
			case "$none_ok" in
				true) type='';;
			esac
		;;
	*)
		case "$tilde" in
			'') value="$ans"
				ansexp="$ans";;
			*)
				value=`UU/filexp $ans`
				case $? in
					0)
						if test "$ans" != "$value"; then
							echo "(That expands to $value on this system.)"
						fi
					;;

					*)	 value="$ans";;
				esac

				ansexp="$value"
				case "$exp_file" in
					'')	 value="$ans";;
				esac
			;;
		esac

		case "$fullpath" in
			true)
				case "$ansexp" in
					/*) 	value="$ansexp" ;;
					*)
						redo=true
						case "$already" in
							true)
								echo "I shall only accept a full path name, as in /bin/ls." >&4
								echo "Use a ! shell escape if you wish to check pathnames." >&4
							;;

							*)
								echo "Please give a full path name, starting with slash." >&4
								case "$tilde" in
										true)
											echo "Note that using ~name is ok provided it expands well." >&4
											already=true
										;;
								esac
						esac
					;;
				esac
			;;
		esac

		case "$redo" in
			'')
			case "$type" in
				File)
						if test -f "$ansexp"; then
							type=''
						elif test -r "$ansexp" || (test -h "$ansexp") >/dev/null 2>&1
						then
							echo "($value is not a plain file, but that's ok.)"
							type=''
						fi
						;;
				Directory)
						if test -d "$ansexp"; then
							type=''
						fi
				;;

				Locate)
						if test -d "$ansexp"; then
							echo "(Looking for $loc_file in directory $value.)"
							value="$value/$loc_file"
							ansexp="$ansexp/$loc_file"
						fi
						if test -f "$ansexp"; then
							type=''
						fi
						case "$nopath_ok" in
							true)	case "$value" in
									*/*) ;;
									*)	echo "Assuming $value will be in people's path."
										type=''
									;;
								esac
							;;
						esac
				;;
			esac

			case "$skip" in
				true) type='';
			esac

			case "$type" in
				'') ;;
				*)
					if test "$fastread" = yes; then
						dflt=y
					else
						dflt=n
					fi
					rp="$what $value doesn't exist.  Use that name anyway?"
					. UU/myread
					dflt=''
					case "$ans" in
						y*) type='';;
						*) echo " ";;
					esac
				;;
			esac
		;;
		esac
	;;
	esac
done

cd UU
ans="$value"
rp="$orig_rp"
dflt="$orig_dflt"
rm -f getfile.ok
EOSC

: determine root of directory hierarchy where package will be installed.
case "$prefix" in
	'')
		dflt=`./loc . /usr/local /usr/local /local /opt /usr`
	;;
	*)
		dflt="$prefix"
	;;
esac
$cat <<EOM

By default, $package will be installed in $dflt/bin, manual
pages under $dflt/man, etc..., i.e. with $dflt as prefix for
all installation directories. Typically set to /usr/local, but you
may choose /usr if you wish to install $package among your system
binaries. If you wish to have binaries under /bin but manual pages
under /usr/local/man, that's ok: you will be prompted separately
for each of the installation directories, the prefix being only used
to set the defaults.

EOM
fn=d~
rp='Installation prefix to use?'
. ./getfile
oldprefix=''
case "$prefix" in
	'') ;;
	*)
		case "$ans" in
			"$prefix") ;;
			*) oldprefix="$prefix";;
		esac
	;;
esac
prefix="$ans"
prefixexp="$ansexp"

: set the prefixit variable, to compute a suitable default value
prefixit='case "$3" in
	""|none)
			case "$oldprefix" in
				"") eval "$1=\"\$$2\"";;
				*)
					case "$3" in
						"") 		eval "$1=";;
						none)
								eval "tp=\"\$$2\"";
								case "$tp" in
									""|" ") eval "$1=\"\$$2\"";;
									*) 	eval "$1=";;
								esac;;
					esac;;
			esac;;
	*)
			eval "tp=\"$oldprefix-\$$2-\""; eval "tp=\"$tp\"";
			case "$tp" in
				--|/*--|\~*--) eval "$1=\"$prefix/$3\"";;
				/*-$oldprefix/*|\~*-$oldprefix/*)
									eval "$1=\`echo \$$2 | sed \"s,^$oldprefix,$prefix,\"\`";;
				*) eval "$1=\"\$$2\"";;
			esac;;
esac'


: determine where public executables go
echo " "
set dflt bin bin
eval $prefixit
fn=d~
rp='Pathname where the public executables will reside?'
. ./getfile
if $test "X$ansexp" != "X$binexp"; then
	installbin=''
fi

bin="$ans"
binexp="$ansexp"
installbin="$binexp"

: determine where private executables go
set dflt privlib lib/$package
eval $prefixit
$cat <<EOM

There are some auxiliary files for $package that need to be put into a
private library directory that is accessible by everyone.

EOM
fn=d~+
rp='Pathname where the private library files will reside?'
. ./getfile
if $test "X$privlibexp" != "X$ansexp"; then
	installprivlib=''
fi
privlib="$ans"
privlibexp="$ansexp"
installprivlib="$privlibexp"

: determine where manual pages are on this system
echo " "
case "$sysman" in
	'') 
		syspath='/usr/man/man1 /usr/man/mann /usr/man/manl /usr/man/local/man1'
		syspath="$syspath /usr/man/u_man/man1 /usr/share/man/man1"
		syspath="$syspath /usr/catman/u_man/man1 /usr/man/l_man/man1"
		syspath="$syspath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
		syspath="$syspath /usr/man/man.L /local/man/man1 /usr/local/man/man1"
		sysman=`./loc . /usr/man/man1 $syspath`
	;;
esac
if $test -d "$sysman"; then
	echo "System manual is in $sysman." >&4
else
	echo "Could not find manual pages in source form." >&4
fi

: set the prefixup variable, to restore leading tilda escape
prefixup='case "$prefixexp" in
	"$prefix") ;;
	*) eval "$1=\`echo \$$1 | sed \"s,^$prefixexp,$prefix,\"\`";;
esac'

: determine where manual pages go
set mansrc mansrc none
eval $prefixit
$cat <<EOM

$spackage has manual pages available in source form.
EOM
case "$nroff" in
	nroff)
		echo "However, you don't have nroff, so they're probably useless to you."
		case "$mansrc" in
			'') mansrc="none";;
		esac
	;;
esac

echo "If you don't want the manual sources installed, answer 'none'."
case "$mansrc" in
	'')
		lookpath="$prefixexp/man/man1 $prefixexp/man/u_man/man1"
		lookpath="$lookpath $prefixexp/man/l_man/man1"
		lookpath="$lookpath /usr/local/man/man1 /opt/man/man1 /usr/man/manl"
		lookpath="$lookpath /usr/man/local/man1 /usr/man/l_man/man1"
		lookpath="$lookpath /usr/local/man/u_man/man1 /usr/local/man/l_man/man1"
		lookpath="$lookpath /usr/man/man.L"
		mansrc=`./loc . $prefixexp/man/man1 $lookpath`
		if $test -d "$mansrc"; then
			dflt="$mansrc"
		else
			dflt="$sysman"
		fi
			set dflt
		eval $prefixup
	;;

	' ') dflt=none;;
	*)  dflt="$mansrc"
	;;
esac

echo " "
fn=dn~
rp='Where do the manual pages (source) go?'
. ./getfile
if test "X$mansrcexp" != "X$ansexp"; then
	installmansrc=''
fi
mansrc="$ans"
mansrcexp="$ansexp"
case "$mansrc" in
	'') mansrc=' '
		installmansrc='';;
esac

installmansrc="$mansrcexp"

case "$mansrc" in
	' ')	manext='0';;
	*l) 	manext=l;;
	*n)	manext=n;;
	*o)	manext=l;;
	*p)	manext=n;;
	*C)	manext=C;;
	*L)	manext=L;;
	*L1)	manext=L1;;
	*) 	manext=1;;
esac

: make some quick guesses about what we are up against
echo " "
$echo $n "Hmm...  $c"
echo exit 1 >bsd
echo exit 1 >linux
d_bsd="$undef"
$cat /usr/include/signal.h /usr/include/sys/signal.h >foo 2>/dev/null
if $contains SIGTSTP foo >/dev/null 2>&1 ; then
	echo "Looks kind of like a BSD system, but we'll see..."
	d_bsd="$define"
	echo exit 0 >bsd
else
	echo "Looks kind of like a Linux system, but we'll see..."
	echo exit 0 >linux
fi

chmod +x bsd linux

$rm -f foo

case "$cc" in
	'')	dflt=cc;;
	*)	 dflt="$cc";;
esac
rp="Use which C compiler?"
. ./myread
cc="$ans"
echo " "
echo "Checking for GNU cc in disguise and/or its version number..." >&4
$cat >gccvers.c <<EOM
#include <stdio.h>
int main() {
#ifdef __GNUC__
#ifdef __VERSION__
	printf("%s\n", __VERSION__);
#else
	printf("%s\n", "1");
#endif
#endif
	exit(0);
}
EOM
if $cc -o gccvers gccvers.c >/dev/null 2>&1; then
	gccversion=`./gccvers`
	case "$gccversion" in
		'') 	echo "You are not using GNU cc." ;;
		*)  	echo "You are using GNU cc $gccversion." ;;
	esac
else
	echo " "
	echo "*** WHOA THERE!!! ***" >&4
	echo "    Your C compiler \"$cc\" doesn't seem to be working!" >&4
	case "$knowitall" in
	'')
	echo "    You'd better start hunting for one and let me know about it." >&4
		exit 1
		;;
	esac
fi
$rm -f gccvers*
case "$gccversion" in
	1*) cpp=`./loc gcc-cpp $cpp $pth` ;;
esac

: What should the include directory be ?
echo " "
$echo $n "Hmm...  $c"
dflt='/usr/include'
incpath=''

case "$usrinc" in
	'')	 ;;
	*)	 dflt="$usrinc";;
esac

case "$xxx_prompt" in
	y)	fn=d/
		echo " "
		rp='Where are the include files you want to use?'
		. ./getfile
		usrinc="$ans"
	;;

	*)	usrinc="$dflt"
	;;
esac

: see how we invoke the C preprocessor
echo " "
echo "Now, how can we feed standard input to your C preprocessor..." >&4
cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
EOT
cd ..
echo 'cat >.$$.c; '"$cc"' -E ${1+"$@"} .$$.c; rm .$$.c' >cppstdin
chmod 755 cppstdin
wrapper=`pwd`/cppstdin
ok='false'
cd UU

if $test "X$cppstdin" != "X" && \
	$cppstdin $cppminus <testcpp.c >testcpp.out 2>&1 && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
then
	echo "You used to use $cppstdin $cppminus so we'll use that again."
	case "$cpprun" in
		'')	 echo "But let's see if we can live without a wrapper..." ;;

		*)
			if $cpprun $cpplast <testcpp.c >testcpp.out 2>&1 && $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
			then
				echo "(And we'll use $cpprun $cpplast to preprocess directly.)"
				ok='true'
			else
				echo "(However, $cpprun $cpplast does not work, let's see...)"
			fi
		;;
	esac
else
	case "$cppstdin" in
		'')
		;;

		*)
			echo "Good old $cppstdin $cppminus does not seem to be of any help..."
		;;
	esac
fi

if $ok; then
	: nothing
elif echo 'Maybe "'"$cc"' -E" will work...'; \
	$cc -E <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -E -" will work...'; \
	$cc -E - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yup, it does."
	x_cpp="$cc -E"
	x_minus='-';
elif echo 'Nope...maybe "'"$cc"' -P" will work...'; \
	$cc -P <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Yipee, that works!"
	x_cpp="$cc -P"
	x_minus='';
elif echo 'Nope...maybe "'"$cc"' -P -" will work...'; \
	$cc -P - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "At long last!"
	x_cpp="$cc -P"
	x_minus='-';
elif echo 'No such luck, maybe "'$cpp'" will work...'; \
	$cpp <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "It works!"
	x_cpp="$cpp"
	x_minus='';
elif echo 'Nixed again...maybe "'$cpp' -" will work...'; \
	$cpp - <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	echo "Hooray, it works!  I was beginning to wonder."
	x_cpp="$cpp"
	x_minus='-';
elif echo 'Uh-uh.  Time to get fancy.  Trying a wrapper...'; \
	$wrapper <testcpp.c >testcpp.out 2>&1; \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
	x_cpp="$wrapper"
	x_minus=''
	echo "Eureka!"
else
	dflt=''
	rp="No dice.  I can't find a C preprocessor.  Name one:"
	. ./myread
	x_cpp="$ans"
	x_minus=''
	$x_cpp <testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 ; then
		echo "OK, that will do." >&4
	else
echo "Sorry, I can't get that to work.  Go find one and rerun Configure." >&4
		exit 1
	fi
fi

case "$ok" in
	false)
		cppstdin="$x_cpp"
		cppminus="$x_minus"
		cpprun="$x_cpp"
		cpplast="$x_minus"
		set X $x_cpp
		shift

		case "$1" in
			"$cpp")
					echo "Perhaps can we force $cc -E using a wrapper..."
					if $wrapper <testcpp.c >testcpp.out 2>&1; $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1
					then
						echo "Yup, we can."
						cppstdin="$wrapper"
						cppminus='';
					else
						echo "Nope, we'll have to live without it..."
					fi
			;;
		esac

		case "$cpprun" in
			"$wrapper")
					cpprun=''
					cpplast=''
		;;
	esac
	;;
esac

case "$cppstdin" in
"$wrapper") ;;
*) $rm -f $wrapper;;
esac
$rm -f testcpp.c testcpp.out

case "$libpth" in
	' ') 	dlist='';;
	'') 	dlist="$loclibpth $plibpth $glibpth";;
	*) 	dlist="$libpth";;
esac

: Now check and see which directories actually exist, avoiding duplicates
libpth=''
for xxx in $dlist
do
    if $test -d $xxx; then
		case " $libpth " in
			*" $xxx "*) 	;;
			*) 		libpth="$libpth $xxx";;
		esac
    fi
done
$cat <<'EOM'

Some systems have incompatible or broken versions of libraries.  Among
the directories listed in the question below, please remove any you
know not to be holding relevant libraries, and add any that are needed.
Say "none" for none.

EOM
case "$libpth" in
	'') 	dflt='none';;
	*)
		set X $libpth
		shift
		dflt=${1+"$@"}
	;;
esac
rp="Directories to use for library searches?"
. ./myread
case "$ans" in
	none) 	libpth=' ';;
	*) 	libpth="$ans";;
esac

: determine optimize, if desired, or use for debug flag also
case "$optimize" in
	' ') 	dflt='none';;
	'') 	dflt='-O';;
	*) 	dflt="$optimize";;
esac
$cat <<EOH

Some C compilers have problems with their optimizers.  By default, $package
compiles with the -O flag to use the optimizer.  Alternately, you might want
to use the symbolic debugger, which uses the -g flag (on traditional Unix
systems).  Either flag can be specified here.  To use neither flag, specify
the word "none".

EOH
rp="What optimizer/debugger flag should be used?"
. ./myread
optimize="$ans"
case "$optimize" in
	'none') optimize=" ";;
esac

dflt=''
: We will not override a previous value, but we might want to
: augment a hint file
case "$hint" in
	none|recommended)
				case "$gccversion" in
					1*) dflt='-fpcc-struct-return' ;;
				esac

				case "$optimize" in
					*-g*) dflt="$dflt -DDEBUGGING";;
				esac

				case "$gccversion" in
					2*) 	if test -d /etc/conf/kconfig.d &&
							$contains _POSIX_VERSION $usrinc/sys/unistd.h >/dev/null 2>&1
						then
							dflt="$dflt -posix"
						fi
					;;
				esac
	;;
esac

case "$mips_type" in
	*BSD*|'')	inclwanted="$locincpth $usrinc";;
	*)		inclwanted="$locincpth $inclwanted $usrinc/bsd";;
esac
for thisincl in $inclwanted; do
	if $test -d $thisincl; then
		if $test x$thisincl != x$usrinc; then
			case "$dflt" in
				*$thisincl*)	;;
				*)		 dflt="$dflt -I$thisincl";;
			esac
		fi
	fi
done

inctest='if $contains $2 $usrinc/$1 >/dev/null 2>&1; then
	xxx=true;
elif $contains $2 $usrinc/sys/$1 >/dev/null 2>&1; then
	xxx=true;
else
	xxx=false;
fi;
if $xxx; then
	case "$dflt" in
		*$2*)	;;
		*)	dflt="$dflt -D$2";;
	esac;
fi'


case "$hint" in
	none|recommended)	dflt="$ccflags $dflt" ;;
	*) 			dflt="$ccflags";;
esac

case "$dflt" in
	''|' ') dflt=none;;
esac
$cat <<EOH

Your C compiler may want other flags.  For this question you should include
-I/whatever and -DWHATEVER flags and any other flags used by the C compiler,
but you should NOT include libraries or ld flags like -lwhatever.  If you
want $package to honor its debug switch, you should include -DDEBUG here.

To use no flags, specify the word "none".

EOH
set X $dflt
shift
dflt=${1+"$@"}
rp="Any additional cc flags?"
. ./myread
case "$ans" in
	none)	ccflags='';;
	*)	ccflags="$ans";;
esac

: the following weeds options from ccflags that are of no interest to cpp
cppflags="$ccflags"
case "$gccversion" in
	1*) cppflags="$cppflags -D__GNUC__"
esac
case "$mips_type" in
	'');;
	*BSD*)	cppflags="$cppflags -DSYSTYPE_BSD";;
esac
case "$cppflags" in
	'');;
	*)
		echo " "
		echo "Let me guess what the preprocessor flags are..." >&4
		set X $cppflags
		shift
		cppflags=''
		$cat >cpp.c <<'EOM'
#define BLURFL foo

BLURFL xx LFRULB
EOM
		previous=''
		for flag in $*
		do
			case "$flag" in
				-*)	 ftry="$flag";;
				*)	 ftry="$previous $flag";;
			esac

			if $cppstdin -DLFRULB=bar $ftry $cppminus <cpp.c             \
				>cpp1.out 2>/dev/null &&                             \
				$cpprun -DLFRULB=bar $ftry $cpplast <cpp.c           \
				>cpp2.out 2>/dev/null &&                             \
				$contains 'foo.*xx.*bar' cpp1.out >/dev/null 2>&1 && \
				$contains 'foo.*xx.*bar' cpp2.out >/dev/null 2>&1
			then
				cppflags="$cppflags $ftry"
					previous=''
				else
					previous="$flag"
			fi
		done

		set X $cppflags
		shift
		cppflags=${1+"$@"}
		case "$cppflags" in
			*-*)	echo "They appear to be: $cppflags";;
		esac

		$rm -f cpp.c cpp?.out
	;;
esac

: flags used in final linking phase
case "$ldflags" in
	'') 	dflt=''
		case "$ccflags" in
			*-posix*)	 dflt="$dflt -posix" ;;
		esac
	;;

	*) dflt="$ldflags";;
esac

: Try to guess additional flags to pick up local libraries.
for thislibdir in $libpth; do
	case " $loclibpth " in
		*" $thislibdir "*)
			case "$dflt " in 
				*"-L$thislibdir "*) 	;;
				*) 			 dflt="$dflt -L$thislibdir" ;;
			esac
		;;
	esac
done

case "$dflt" in
	'') dflt='none' ;;
esac

$cat <<EOH

Your C linker may need flags.  For this question you should
include -L/whatever and any other flags used by the C linker, but you
should NOT include libraries like -lwhatever.

Make sure you include the appropriate -L/path flags if your C linker
does not normally search all of the directories you specified above,
namely
	$libpth
To use no flags, specify the word "none".

EOH

rp="Any additional ld flags (NOT including libraries)?"
. ./myread
case "$ans" in
	none) 	ldflags='';;
	*) 	ldflags="$ans";;
esac
rmlist="$rmlist pdp11"

: coherency check
echo " "
echo "Checking your choice of C compiler and flags for coherency..." >&4
set X $cc $optimize $ccflags $ldflags try.c -o try
shift
$cat >try.msg <<EOM
I've tried to compile and run a simple program with:

	$*
	./try

and I got the following output:

EOM
$cat > try.c <<'EOF'
#include <stdio.h>
main() { exit(0); }
EOF
dflt=y
if sh -c "$cc $optimize $ccflags try.c -o try $ldflags" >>try.msg 2>&1; then
	if sh -c './try' >>try.msg 2>&1; then
		dflt=n
	else
		echo "The program compiled OK, but exited with status $?." >>try.msg
		rp="You have a problem.  Shall I abort Configure"
		dflt=y
	fi
else
	echo "I can't compile the test program." >>try.msg
	rp="You have a BIG problem.  Shall I abort Configure"
	dflt=y
fi

case "$dflt" in
	y)
		$cat try.msg
		case "$knowitall" in
			'')
				echo "(The supplied flags might be incorrect with this C compiler.)"
			;;

			*)	dflt=n;;
		esac

		echo " "
		. ./myread

		case "$ans" in
			n*|N*)	;;

			*)	echo "Ok.  Stopping Configure." >&4
				exit 1
			;;
		esac
	;;

	n) echo "OK, that should do.";;
esac

$rm -f try try.* core

: Initialize h_fcntl
h_fcntl=false

: Initialize h_sysfile
h_sysfile=false

: compute shared library extension
case "$so" in
	'')
		if xxx=`./loc libc.sl X $libpth`; $test -f "$xxx"; then
			dflt='sl'
		else
			dflt='so'
		fi
	;;

	*) 	dflt="$so";;
esac
$cat <<EOM

On some systems, shared libraries may be available.  Answer 'none' if
you want to suppress searching of shared libraries for the remaining
of this configuration.

EOM
rp='What is the file extension used for shared libraries?'
. ./myread
so="$ans"

: Define several unixisms.
: Hints files or command line option can be used to override them.
case "$_a" in
'') _a='.a';;
esac
case "$_o" in
	'') 	_o='.o';;
esac

: Looking for optional libraries
echo " "
echo "Checking for optional libraries..." >&4

case "$libs" in
' '|'') dflt='';;
	*)	 dflt="$libs";;
esac

case "$libswanted" in
	'')	 libswanted='c_s';;
esac

for thislib in $libswanted; do
	
	if xxx=`./loc lib$thislib.$so.[0-9]'*' X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
			*"-l$thislib "*)	;;
			*) 			dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib.$so X $libpth` ; $test -f "$xxx"; then
		echo "Found -l$thislib (shared)."
		case " $dflt " in
			*"-l$thislib "*)	;;
			*)			dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib$thislib$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
			*"-l$thislib "*)	;;
			*) 			dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc $thislib$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
			*"-l$thislib "*)	;;
			*) 			dflt="$dflt -l$thislib";;
		esac
	elif xxx=`./loc lib${thislib}_s$_a X $libpth`; $test -f "$xxx"; then
		echo "Found -l${thislib}_s."
		case " $dflt " in
			*"-l$thislib "*)	;;
			*) 			dflt="$dflt -l${thislib}_s";;
		esac
	elif xxx=`./loc Slib$thislib$_a X $xlibpth`; $test -f "$xxx"; then
		echo "Found -l$thislib."
		case " $dflt " in
			*"-l$thislib "*)	;;
			*) 			dflt="$dflt -l$thislib";;
		esac
	else
		echo "No -l$thislib."
	fi
done
set X $dflt
shift
dflt="$*"

case "$libs" in
	'')	dflt="$dflt";;
	*)	dflt="$libs";;
esac

case "$dflt" in
	' '|'')	dflt='none';;
esac

$cat <<EOM
 
Some versions of Unix support shared libraries, which make executables smaller
but make load time slightly longer.

On some systems, mostly System V Release 3's, the shared library is included
by putting the option "-lc_s" as the last thing on the cc command line when
linking.  Other systems use shared libraries by default.  There may be other
libraries needed to compile $package on your machine as well.  If your system
needs the "-lc_s" option, include it here.  Include any other special libraries
here as well.  Say "none" for none.
EOM

echo " "
rp="Any additional libraries?"
. ./myread
case "$ans" in
	none)	libs=' ';;
	*)	libs="$ans";;
esac

: set up the script used to warn in case of inconsistency
cat <<EOS >whoa
$startsh
EOS
cat <<'EOSC' >>whoa
dflt=y
echo " "
echo "*** WHOA THERE!!! ***" >&4
echo "    The $hint value for \$$var on this machine was \"$was\"!" >&4
rp="    Keep the $hint value?"
. ./myread
case "$ans" in
	y) td=$was; tu=$was;;
esac
EOSC

: function used to set $1 to $val
setvar='var=$1; eval "was=\$$1"; td=$define; tu=$undef;
case "$val$was" in
	$define$undef)	. ./whoa; eval "$var=\$td";;
	$undef$define)	. ./whoa; eval "$var=\$tu";;
	*)		eval "$var=$val";;
esac'

echo " "
echo "Checking for GNU C Library..." >&4
cat >gnulibc.c <<EOM
int
main()
{
	return __libc_main();
}
EOM
if $cc $ccflags $ldflags -o gnulibc gnulibc.c $libs >/dev/null 2>&1 && \
  ./gnulibc | $contains '^GNU C Library' >/dev/null 2>&1; then
	val="$define"
	echo "You are using the GNU C Library"
else
	val="$undef"
	echo "You are not using the GNU C Library"
fi
$rm -f gnulibc*
set d_gnulibc
eval $setvar

: see if nm is to be used to determine whether a symbol is defined or not
case "$usenm" in
	'')
		case "$d_gnulibc" in
			$define)
					dflt=n
			;;

			*)
					dflt=`egrep 'inlibc|csym' ../Configure | wc -l 2>/dev/null`
					if $test $dflt -gt 20; then
						dflt=y
					else
						dflt=n
					fi
			;;
		esac
	;;

	*)
		case "$usenm" in
			true) 	dflt=y;;
			*) 	dflt=n;;
		esac
	;;
esac
$cat <<EOM

I can use 'nm' to extract the symbols from your C libraries. This is a time
consuming task which may generate huge output on the disk (up to 3 megabytes)
but that should make the symbols extraction faster. The alternative is to skip
the 'nm' extraction part and to compile a small test program instead to
determine whether each symbol is present. If you have a fast C compiler and/or
if your 'nm' output cannot be parsed, this may be the best solution.
You shouldn't let me use 'nm' if you have the GNU C Library.

EOM
rp='Shall I use nm to extract C symbols from the libraries?'
. ./myread
case "$ans" in
	n|N) 	usenm=false;;
	*) 	usenm=true;;
esac

runnm=$usenm
case "$reuseval" in
true) runnm=false;;
esac

: nm options which may be necessary
case "$nm_opt" in
'') if $test -f /mach_boot; then
		nm_opt=''
	elif $test -d /usr/ccs/lib; then
		nm_opt='-p'
	elif $test -f /dgux; then
		nm_opt='-p'
	else
		nm_opt=''
	fi;;
esac

: nm options which may be necessary for shared libraries but illegal
: for archive libraries.  Thank you, Linux.
case "$nm_so_opt" in
	'')	case "$myuname" in
		*linux*)
			if nm --help | $grep 'dynamic' > /dev/null 2>&1; then
				nm_so_opt='--dynamic'
			fi
		;;
		esac
	;;
esac


case "$runnm" in
	true)
		: get list of predefined functions in a handy place
		echo " "
		case "$libc" in
			'')		libc=unknown
					case "$libs" in
						*-lc_s*) libc=`./loc libc_s$_a $libc $libpth`
					esac
			;;
		esac

		libnames='';
		case "$libs" in
			'') 	;;
			*)  	for thislib in $libs; do
					case "$thislib" in
						-lc|-lc_s)
							: Handle C library specially below.
						;;

						-l*)
							thislib=`echo $thislib | $sed -e 's/^-l//'`
							if try=`./loc lib$thislib.$so.'*' X $libpth`; $test -f "$try"; then
								:
							elif try=`./loc lib$thislib.$so X $libpth`; $test -f "$try"; then
								:
							elif try=`./loc lib$thislib$_a X $libpth`; $test -f "$try"; then
								:
							elif try=`./loc $thislib$_a X $libpth`; $test -f "$try"; then
								:
							elif try=`./loc lib$thislib X $libpth`; $test -f "$try"; then
								:
							elif try=`./loc $thislib X $libpth`; $test -f "$try"; then
								:
							elif try=`./loc Slib$thislib$_a X $xlibpth`; $test -f "$try"; then
								:
							else
								try=''
							fi
							libnames="$libnames $try"
						;;
	
						*) libnames="$libnames $thislib" ;;
					esac
				done
	;;
esac

xxx=normal
case "$libc" in
	unknown)
			set /lib/libc.$so
			for xxx in $libpth; do
				$test -r $1 || set $xxx/libc.$so
				$test -r $1 || 					  \
				set `echo blurfl; echo /usr/lib/libc.$so.[0-9]* | \
				tr ' ' '\012' | egrep -v '\.[A-Za-z]*$' | $sed -e '
				h
				s/[0-9][0-9]*/0000&/g
				s/0*\([0-9][0-9][0-9][0-9][0-9]\)/\1/g
				G
				s/\n/ /' | \
			 	sort | $sed -e 's/^.* //'`
			eval set \$$#
		done
		$test -r $1 || set /usr/ccs/lib/libc.$so
		$test -r $1 || set /lib/libsys_s$_a

	;;

	*)
		set blurfl
	;;
esac

if $test -r "$1"; then
	echo "Your (shared) C library seems to be in $1."
	libc="$1"
elif $test -r /lib/libc && $test -r /lib/clib; then
	echo "Your C library seems to be in both /lib/clib and /lib/libc."
	xxx=apollo
	libc='/lib/clib /lib/libc'
	if $test -r /lib/syslib; then
		echo "(Your math library is in /lib/syslib.)"
		libc="$libc /lib/syslib"
	fi
elif $test -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	echo "Your C library seems to be in $libc, as you said before."
elif $test -r $incpath/usr/lib/libc$_a; then
	libc=$incpath/usr/lib/libc$_a;
	echo "Your C library seems to be in $libc.  That's fine."
elif $test -r /lib/libc$_a; then
	libc=/lib/libc$_a;
	echo "Your C library seems to be in $libc.  You're normal."
else
	if tans=`./loc libc$_a blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc libc blurfl/dyick $libpth`; $test -r "$tans"; then
		libnames="$libnames "`./loc clib blurfl/dyick $libpth`
	elif tans=`./loc clib blurfl/dyick $libpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Slibc$_a blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	elif tans=`./loc Mlibc$_a blurfl/dyick $xlibpth`; $test -r "$tans"; then
		:
	else
		tans=`./loc Llibc$_a blurfl/dyick $xlibpth`
	fi
	if $test -r "$tans"; then
		echo "Your C library seems to be in $tans, of all places."
		libc=$tans
	else
		libc='blurfl'
	fi
fi
if $test $xxx = apollo -o -r "$libc" || (test -h "$libc") >/dev/null 2>&1; then
	dflt="$libc"
	cat <<EOM

If the guess above is wrong (which it might be if you're using a strange
compiler, or your machine supports multiple models), you can override it here.

EOM
else
	dflt=''
	echo $libpth | tr ' ' '\012' | sort | uniq > libpath
	cat >&4 <<EOM
I can't seem to find your C library.  I've looked in the following places:

EOM
	$sed 's/^/	/' libpath
	cat <<EOM

None of these seems to contain your C library. I need to get its name...

EOM
fi
fn=f
rp='Where is your C library?'
. ./getfile
libc="$ans"

echo " "
echo $libc $libnames | tr ' ' '\012' | sort | uniq > libnames
set X `cat libnames`
shift
xxx=files

case $# in 
	1)	xxx=file;
esac

echo "Extracting names from the following $xxx for later perusal:" >&4
echo " "
$sed 's/^/	/' libnames >&4
echo " "
$echo $n "This may take a while...$c" >&4

for file in $*; do
	case $file in
		*$so*)		nm $nm_so_opt $nm_opt $file 2>/dev/null;;
		*)		 nm $nm_opt $file 2>/dev/null;;
	esac
done >libc.tmp

$echo $n ".$c"
$grep fprintf libc.tmp > libc.ptf
xscan='eval "<libc.ptf $com >libc.list"; $echo $n ".$c" >&4'
xrun='eval "<libc.tmp $com >libc.list"; echo "done" >&4'
xxx='[ADTSIW]'
if com="$sed -n -e 's/__IO//' -e 's/^.* $xxx  *_[_.]*//p' -e 's/^.* $xxx  *//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__*//' -e 's/^\([a-zA-Z_0-9$]*\).*xtern.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/|UNDEF/d' -e '/FUNC..GL/s/^.*|__*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.* D __*//p' -e 's/^.* D //p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^_//' -e 's/^\([a-zA-Z_0-9]*\).*xtern.*text.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$grep '|' | $sed -n -e '/|COMMON/d' -e '/|DATA/d' \
				-e '/ file/d' -e 's/^\([^ 	]*\).*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^.*|FUNC |GLOB .*|//p' -e 's/^.*|FUNC |WEAK .*|//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^__//' -e '/|Undef/d' -e '/|Proc/s/ .*//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e '/Def. Text/s/.* \([^ ]*\)\$/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/^[-0-9a-f ]*_\(.*\)=.*/\1/p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
elif com="$sed -n -e 's/.*\.text n\ \ \ \.//p'";\
	eval $xscan;\
	$contains '^fprintf$' libc.list >/dev/null 2>&1; then
		eval $xrun
else
	nm -p $* 2>/dev/null >libc.tmp
	$grep fprintf libc.tmp > libc.ptf
	if com="$sed -n -e 's/^.* [ADTSIW]  *_[_.]*//p' -e 's/^.* [ADTSIW] //p'";\
		eval $xscan; $contains '^fprintf$' libc.list >/dev/null 2>&1
	then
		nm_opt='-p'
		eval $xrun
	else
		echo " "
		echo "nm didn't seem to work right. Trying ar instead..." >&4
		com=''
		if ar t $libc > libc.tmp; then
			for thisname in $libnames; do
				ar t $thisname >>libc.tmp
			done
			$sed -e "s/\\$_o\$//" < libc.tmp > libc.list
			echo "Ok." >&4
		else
			echo "ar didn't seem to work right." >&4
			echo "Giving up." >&4
			exit 1
		fi
	fi
fi
nm_extract="$com"
if $test -f /lib/syscalls.exp; then
	echo " "
	echo "Also extracting names from /lib/syscalls.exp for good ole AIX..." >&4
	$sed -n 's/^\([^ 	]*\)[ 	]*syscall$/\1/p' /lib/syscalls.exp >>libc.list
fi
;;
esac
$rm -f libnames libpath

: is a C symbol defined?
csym='tlook=$1;

case "$3" in
	-v) 	tf=libc.tmp; tc=""; tdc="";;
	-a) 	tf=libc.tmp; tc="[0]"; tdc="[]";;
	*) 	tlook="^$1\$"; tf=libc.list; tc="()"; tdc="()";;
esac;

tx=yes;
case "$reuseval-$4" in
	true-) 		;;
	true-*)		tx=no; eval "tval=\$$4";
			case "$tval" in
				"") 	tx=yes
				;;
			esac
	;;
esac;

case "$tx" in
	yes)
		case "$runnm" in
			true)
				if $contains $tlook $tf >/dev/null 2>&1;
				then
					tval=true;
				else
					tval=false;
				fi
			;;

			*)
				echo "main() { extern short $1$tdc; printf(\"%hd\", $1$tc); }" > t.c;
				if $cc $ccflags $ldflags -o t t.c $libs >/dev/null 2>&1;
				then
					tval=true;
				else
					tval=false;
				fi;
			$rm -f t t.c;;
		esac
	;;

	*)
		case "$tval" in
			$define)	tval=true
			;;

			*) 		tval=false
			;;
		esac;;
esac;
eval "$2=$tval"'

: define an is-in-libc? function
inlibc='echo " "; td=$define; tu=$undef;
sym=$1; var=$2; eval "was=\$$2";
tx=yes;

case "$reuseval$was" in
	true) ;;
	true*) tx=no;;
esac;

case "$tx" in
	yes)
		set $sym tres -f;
		eval $csym;
		case "$tres" in
			true)
				echo "$sym() found." >&4;
				case "$was" in
					$undef) . ./whoa;
				esac;
				eval "$var=\$td"
			;;

			*)
				echo "$sym() NOT found." >&4;
				case "$was" in
					$define) . ./whoa;
					esac;
					eval "$var=\$tu"
			;;
		esac;;

	*)
		case "$was" in
			$define)	echo "$sym() found." >&4
			;;
			*) 		echo "$sym() NOT found." >&4
			;;
	esac;;
esac'

: determine filename position in cpp output
echo " "
echo "Computing filename position in cpp output for #include directives..." >&4
echo '#include <stdio.h>' > foo.c
$cat >fieldn <<EOF
$startsh
$cppstdin $cppflags $cppminus <foo.c 2>/dev/null | \
$grep '^[ 	]*#.*stdio\.h' | \
while read cline; do
	pos=1
	set \$cline
	while $test \$# -gt 0; do
		if $test -r \`echo \$1 | $tr -d '"'\`; then
			echo "\$pos"
			exit 0
		fi
		shift
		pos=\`expr \$pos + 1\`
	done
done
EOF
chmod +x fieldn
fieldn=`./fieldn`
$rm -f foo.c fieldn
case $fieldn in
	'')	 pos='???';;
	1)	 pos=first;;
	2)	 pos=second;;
	3)	 pos=third;;
	*)	 pos="${fieldn}th";;
esac
echo "Your cpp writes the filename in the $pos field of the line."

: locate header file
$cat >findhdr <<EOF
$startsh
wanted=\$1
name=''
if test -f $usrinc/\$wanted; then
	echo "$usrinc/\$wanted"
	exit 0
fi
awkprg='{ print \$$fieldn }'
echo "#include <\$wanted>" > foo\$\$.c
$cppstdin $cppminus $cppflags < foo\$\$.c 2>/dev/null | \
$grep "^[ 	]*#.*\$wanted" | \
while read cline; do
	name=\`echo \$cline | $awk "\$awkprg" | $tr -d '"'\`

	case "\$name" in
		*/\$wanted) echo "\$name"; exit 0
		;;
		*) name=''
		;;
	esac;
done;
$rm -f foo\$\$.c;

case "\$name" in
	'')	 exit 1;;
esac
EOF
chmod +x findhdr

: access call always available on UNIX
set access d_access
eval $inlibc

: locate the flags for 'access()'
case "$d_access" in
	"$define")
			echo " "
			$cat >access.c <<'EOCP'
			#include <sys/types.h>
			#ifdef I_FCNTL
			#include <fcntl.h>
			#endif /* I_FCNTL */

			#ifdef I_SYS_FILE
			#include <sys/file.h>
			#endif /* I_SYS_FILE */

			#ifdef I_UNISTD
			#include <unistd.h>
			#endif /* I_UNISTD */

			main() {
				exit(R_OK);
			}
EOCP

	: check sys/file.h first, no particular reason here
	if $test `./findhdr sys/file.h` && \
		$cc $cppflags -DI_SYS_FILE access.c -o access >/dev/null 2>&1 ; then
		h_sysfile=true;
		echo "<sys/file.h> defines the *_OK access constants." >&4
	elif $test `./findhdr fcntl.h` && \
		$cc $cppflags -DI_FCNTL access.c -o access >/dev/null 2>&1 ; then
		h_fcntl=true;
		echo "<fcntl.h> defines the *_OK access constants." >&4
	elif $test `./findhdr unistd.h` && \
		$cc $cppflags -DI_UNISTD access.c -o access >/dev/null 2>&1 ; then
		echo "<unistd.h> defines the *_OK access constants." >&4
	else
		echo "I can't find the four *_OK access constants--I'll use mine." >&4
	fi
	;;
esac
$rm -f access*

: Look for GNU-cc style attribute checking
echo " "
echo "Checking whether your compiler can handle __attribute__ ..." >&4
$cat >attrib.c <<'EOCP'
#include <stdio.h>
void croak (char* pat,...) __attribute__((format(printf,1,2),noreturn));
EOCP
if $cc $ccflags -c attrib.c >attrib.out 2>&1 ; then
	if $contains 'warning' attrib.out >/dev/null 2>&1; then
		echo "Your C compiler doesn't fully support __attribute__."
		val="$undef"
	else
		echo "Your C compiler supports __attribute__."
		val="$define"
	fi
else
	echo "Your C compiler doesn't seem to understand __attribute__ at all."
	val="$undef"
fi
set d_attribut
eval $setvar
$rm -f attrib*

: check for const keyword
echo " "
echo 'Checking to see if your C compiler knows about "const"...' >&4
$cat >const.c <<'EOCP'
typedef struct spug { int drokk; } spug;
main()
{
	const char *foo;
	const spug y;
}
EOCP
if $cc -c $ccflags const.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_const
eval $setvar

: see how we invoke the C preprocessor
$cat <<EOM

$package needs to be able to preprocess its input files in a mode which
preserves comments, which is often not the default behaviour.  It should run
the C preprocessor you will use when compiling your own source code, which
should be ISO/ANSI C compliant if you want $package to handle the latest
standard C.  I will try to guess, but I might guess wrongly because it is not
necessarily the same preprocessor used to build $package.

EOM
$cat <<'EOT' >testcpp.c
#define ABC abc
#define XYZ xyz
ABC.XYZ
/* comment */
EOT
:
if $test "X$cppfilecom" != "X" && \
	$cppfilecom testcpp.c </dev/null >testcpp.out 2>/dev/null && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
	$contains comment testcpp.out >/dev/null 2>&1
then
	echo "You used to use $cppfilecom so we'll use that again."
elif echo 'Maybe "'$cc' -E -C" will work...' && \
	$cc -E -C testcpp.c </dev/null >testcpp.out 2>/dev/null && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
	$contains comment testcpp.out >/dev/null 2>&1
then
	echo "It works!"
	cppfilecom="$cc -E -C"
elif echo 'Nope...maybe "'"$cc"' -P -C" will work...' && \
	$cc -P -C testcpp.c </dev/null >testcpp.out 2>/dev/null && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
	$contains comment testcpp.out >/dev/null 2>&1
then
	echo "Yup, that does."
	cppfilecom="$cc -P -C"
elif echo 'No such luck, maybe "'"$cpp"' -C" will work...' && \
	$cpp -C testcpp.c </dev/null >testcpp.out 2>/dev/null && \
	$contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
	$contains comment testcpp.out >/dev/null 2>&1
then
	echo "Yup, it does."
	cppfilecom="$cpp -C"
else
	cppfilecom=''
	$cat <<'EOM'
I can't find a C preprocessor that will preserve comments. Please name one.
EOM
fi
:
dflt="$cppfilecom"
cont=true
while $test "$cont" ; do
	echo " "
	rp="How should $package run your preprocessor preserving comments?"
	. ./myread
	cppfilecom="$ans"
	$cppfilecom testcpp.c >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
		$contains comment testcpp.out >/dev/null 2>&1
	then
		echo "OK, that will do."
		cont=''
	else
		echo "Sorry, I can't get that to work."
	fi
done

: Now see if it ignores header files.
cp testcpp.c testcpp.h
$cppfilecom testcpp.h >testcpp.out 2>&1
if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
	$contains comment testcpp.out >/dev/null 2>&1
then
	echo "Terrific; it processes .h files passed on the command line too."
	val="$undef"
else
	echo "It ignores .h files on the command line; pity."
	val="$define"
fi
set d_cppignhdrs
eval $setvar

: Now see how to send stdin to it.
echo " "
cp testcpp.c testcpp.h
$cppfilecom <testcpp.h >testcpp.out 2>&1
if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
	$contains comment testcpp.out >/dev/null 2>&1
then
	echo "Great; and it will read stdin if passed no arguments."
	val="$define"
	cppstdinflags=''
else
	$cppfilecom - <testcpp.h >testcpp.out 2>&1
	if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
		$contains comment testcpp.out >/dev/null 2>&1
	then
		echo "Great; and it can read stdin by passing it '-'."
		val="$define"
		cppstdinflags='-'
	else
		$cat <<FOO
Unfortunately, I can't find an easy way to get that preprocessor to read from
standard input. Do you know any flags I can pass it to get it to do so?
If that preprocessor can't read directly form standard input, answer 'none'.

FOO
	val='dunno'
	while $test "$val" = "dunno"; do
		rp='Flags to get preprocessor to read stdin?'
		dflt='none'
		. ./myread
		if $test $ans = 'none'; then
			echo "Oh well, if $package wants it done, it will do it for itself."
			val="$undef"
		else
			$cppfilecom $ans <testcpp.h >testcpp.out 2>&1
			if $contains 'abc.*xyz' testcpp.out >/dev/null 2>&1 && \
				$contains comment testcpp.out >/dev/null 2>&1
			then
				echo "Good; that works fine."
				val="$define"
				cppstdinflags="$ans"
			else
				echo "Sorry, I couldn't get that to work."
			fi
		fi
	done
	fi
fi
set d_cppcanstdin
eval $setvar

: cleanup cpp test files anyway
$rm -f testcpp.*

: see if we can have long filenames
echo " "
rmlist="$rmlist /tmp/cf$$"
$test -d /tmp/cf$$ || mkdir /tmp/cf$$
first=123456789abcdef
second=/tmp/cf$$/$first
$rm -f $first $second
if (echo hi >$first) 2>/dev/null; then
	if $test -f 123456789abcde; then
		echo 'You cannot have filenames longer than 14 characters.  Sigh.' >&4
		val="$undef"
	else
		if (echo hi >$second) 2>/dev/null; then
			if $test -f /tmp/cf$$/123456789abcde; then
				$cat <<'EOM'
That's peculiar... You can have filenames longer than 14 characters, but only
on some of the filesystems.  Maybe you are using NFS.  Anyway, to avoid problems
I shall consider your system cannot support long filenames at all.
EOM
				val="$undef"
			else
				echo 'You can have filenames longer than 14 characters.' >&4
				val="$define"
			fi
		else
			$cat <<'EOM'
How confusing! Some of your filesystems are sane enough to allow filenames
longer than 14 characters but some others like /tmp can't even think about them.
So, for now on, I shall assume your kernel does not allow them at all.
EOM
			val="$undef"
		fi
	fi
else
	$cat <<'EOM'
You can't have filenames longer than 14 chars.  You can't even think about them!
EOM
	val="$undef"
fi 
set d_flexfnam
eval $setvar
$rm -rf /tmp/cf$$ 123456789abcde*

: see which of string.h or strings.h is needed
echo " "
strings=`./findhdr string.h`
if $test "$strings" && $test -r "$strings"; then
	echo "Using <string.h> instead of <strings.h>." >&4
	val="$define"
else
	val="$undef"
	strings=`./findhdr strings.h`
	if $test "$strings" && $test -r "$strings"; then
		echo "Using <strings.h> instead of <string.h>." >&4
	else
		echo "No string header found -- You'll surely have problems." >&4
	fi
fi
set i_string
eval $setvar
case "$i_string" in
	"$undef") strings=`./findhdr strings.h`
	;;
	*)	  strings=`./findhdr string.h`
	;;
esac

: index or strchr
echo " "
if set index val -f; eval $csym; $val; then
	if set strchr val -f d_strchr; eval $csym; $val; then
		if $contains strchr "$strings" >/dev/null 2>&1 ; then
			val="$define"
			vali="$undef"
			echo "strchr() found." >&4
		else
			val="$undef"
			vali="$define"
			echo "index() found." >&4
		fi
	else
		val="$undef"
		vali="$define"
		echo "index() found." >&4
	fi
else
	if set strchr val -f d_strchr; eval $csym; $val; then
		val="$define"
		vali="$undef"
		echo "strchr() found." >&4
	else
		echo "No index() or strchr() found!" >&4
		val="$undef"
		vali="$undef"
	fi
fi
set d_strchr; eval $setvar
val="$vali"
set d_index; eval $setvar

: see if link exists
set link d_link
eval $inlibc

: Locate the flags for 'open()'
echo " "
$cat >open3.c <<'EOCP'
#include <sys/types.h>
#ifdef I_FCNTL
#include <fcntl.h>
#endif
#ifdef I_SYS_FILE
#include <sys/file.h>
#endif
main() {
	if(O_RDONLY);
#ifdef O_TRUNC
	exit(0);
#else
	exit(1);
#endif
}
EOCP
: check sys/file.h first to get FREAD on Sun
if $test `./findhdr sys/file.h` && \
		$cc $cppflags "-DI_SYS_FILE" open3.c -o open3 >/dev/null 2>&1 ; then
	h_sysfile=true;
	echo "<sys/file.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
elif $test `./findhdr fcntl.h` && \
		$cc "-DI_FCNTL" open3.c -o open3 >/dev/null 2>&1 ; then
	h_fcntl=true;
	echo "<fcntl.h> defines the O_* constants..." >&4
	if ./open3; then
		echo "and you have the 3 argument form of open()." >&4
		val="$define"
	else
		echo "but not the 3 argument form of open().  Oh, well." >&4
		val="$undef"
	fi
else
	val="$undef"
	echo "I can't find the O_* constant definitions!  You got problems." >&4
fi
set d_open3
eval $setvar
$rm -f open3*

: see if strftime exists
set strftime d_strftime
eval $inlibc

: see if strstr exists
set strstr d_strstr
eval $inlibc

: see if symlink exists
set symlink d_symlink
eval $inlibc

: check for volatile keyword
echo " "
echo 'Checking to see if your C compiler knows about "volatile"...' >&4
$cat >try.c <<'EOCP'
main()
{
	typedef struct _goo_struct goo_struct;
	goo_struct * volatile goo = ((goo_struct *)0);
	struct _goo_struct {
		long long_int;
		int reg_int;
		char char_var;
	};
	typedef unsigned short foo_t;
	char *volatile foo;
	volatile int bar;
	volatile foo_t blech;
	foo = foo;
}
EOCP
if $cc -c $ccflags try.c >/dev/null 2>&1 ; then
	val="$define"
	echo "Yup, it does."
else
	val="$undef"
	echo "Nope, it doesn't."
fi
set d_volatile
eval $setvar
$rm -f try.*

: preserve RCS keywords in files with variable substitution, grrr
Id='$Id'

: check for void type
echo " "
echo "Checking to see how well your C compiler groks the void type..." >&4
echo " "
$cat >&4 <<EOM
  Support flag bits are:
    1: basic void declarations.
    2: arrays of pointers to functions returning void.
    4: operations between pointers to and addresses of void functions.
    8: generic void pointers.
EOM
echo " "
case "$voidflags" in
	'')
		$cat >try.c <<'EOCP'

#if TRY & 1
void sub() {
#else
sub() {
#endif /* TRY & 1 */
				/*----------------------------*/
	extern void moo();	/* function returning void    */
	void (*goo)();		/* ptr to func returning void */
				/*----------------------------*/

	#if TRY & 8
				/*-------------*/
	void *hue;		/* generic ptr */
				/*-------------*/
	#endif /* TRY & 8 */

	#if TRY & 2
	void (*foo[10])();
	#endif /* TRY & 2 */

	#if TRY & 4
		if(goo == moo) {
			exit(0);
		}
	#endif /* TRY & 4 */
		exit(0);
	}

	main()
	{ sub();
	}
EOCP
		if $cc $ccflags -c -DTRY=$defvoidused try.c >.out 2>&1 ; then
			voidflags=$defvoidused
			echo "It appears to support void to the level $package wants ($defvoidused)."
			if $contains warning .out >/dev/null 2>&1; then
				echo "However, you might get some warnings that look like this:"
				$cat .out
			fi
		else
			echo "Hmm, your compiler has some difficulty with void. Checking further..." >&4
			if $cc $ccflags -c -DTRY=1 try.c >/dev/null 2>&1; then
				echo "It supports 1..."
				if $cc $ccflags -c -DTRY=3 try.c >/dev/null 2>&1; then
					echo "It also supports 2..."
					if $cc $ccflags -c -DTRY=7 try.c >/dev/null 2>&1; then
						voidflags=7
						echo "And it supports 4 but not 8 definitely."
					else
						echo "It doesn't support 4..."
						if $cc $ccflags -c -DTRY=11 try.c >/dev/null 2>&1; then
							voidflags=11
							echo "But it supports 8."
						else
							voidflags=3
							echo "Neither does it support 8."
						fi
					fi
				else
					echo "It does not support 2..."
					if $cc $ccflags -c -DTRY=13 try.c >/dev/null 2>&1; then
						voidflags=13
						echo "But it supports 4 and 8."
					else
						if $cc $ccflags -c -DTRY=5 try.c >/dev/null 2>&1; then
							voidflags=5
							echo "And it supports 4 but has not heard about 8."
						else
							echo "However it supports 8 but not 4."
						fi
					fi
				fi
			else
				echo "There is no support at all for void."
				voidflags=0
			fi
		fi
esac


case "$voidflags" in
"$defvoidused") ;;
*)
	dflt="$voidflags";
	rp="Your void support flags add up to what?"
	. ./myread
	voidflags="$ans"
	;;
esac

$rm -f try.* .out

: determine lexical analyser generator
case "$lex" in
	'')	 dflt=lex;;
	*) 	dflt="$lex";;
esac
echo " "
if $test -f "$flex"; then
	rp='Which lexical analyser generator (lex or flex) shall I use?'
else
	rp='Which lexical analyser generator shall I use?'
fi
. ./myread
lex="$ans"


: if using lex this will normally be useless, but flex frequently takes args
echo " "

case "$lexflags" in
	'') dflt='none';;
	*) dflt="$lexflags";;
esac

rp="What flags should be given to $lex?"
. ./myread
case "$ans" in
	none)	lexflags='';;
	*) 	lexflags="$ans";;
esac

: determine compiler compiler
case "$yacc" in
	'')	dflt=yacc;;
	*)	dflt="$yacc";;
esac

echo " "
comp='yacc'
if $test -f "$byacc"; then
	dflt="$byacc"
	comp="byacc or $comp"
fi
if $test -f "$bison"; then
	comp="$comp or bison -y"
fi
rp="Which compiler compiler ($comp) shall I use?"
. ./myread
yacc="$ans"

case "$yacc" in
	*bis*)
		case "$yacc" in
			*-y*)	;;
			*)
				yacc="$yacc -y"
				echo "(Adding -y option to bison to get yacc-compatible behaviour.)"
			;;
		esac
	;;
esac

: see if we need extra yacc flags
dflt="$yaccflags"
case "$dflt" in
	'')	dflt=none;;
esac
$cat <<EOH

Your yacc program may need extra flags to normally process the parser sources.
Do NOT specify any -d or -v flags here, since those are explicitely known
by the various Makefiles. However, if your machine has strange/undocumented
options (like -Sr# on SCO to specify the maximum number of grammar rules), then
please add them here.  To use no flags, specify the word "none".

EOH
rp="Any additional yacc flags?"
. ./myread
case "$ans" in
none) yaccflags='';;
*) yaccflags="$ans";;
esac

: see if we should include -ly
echo " "
case "$yacc" in
	*byacc*)
			echo "You are using byacc, so I won't look for a yacc library." >&4
			libyacc=''
	;;

	*yacc)
			xxx=`./loc liby$_a x $libpth`
			case "$xxx" in
				x)
					echo "No yacc library found." >&4
					libyacc=''
				;;

				*)
					echo "yacc library found in $xxx." >&4
					libyacc="$xxx"
				;;
			esac
	;;

	*bison*)
			echo "You are using bison, so I won't look for a yacc library." >&4
			libyacc=''
	;;

	*)
			echo "You don't seem to have yacc, so I won't look for the yacc library." >&4
			libyacc=''
	;;
esac

: find out how to generate dependencies
echo " "
echo "Checking how to generate makefile dependencies on your machine..." >&4
toplev=`cd ..;pwd`
$cat >dep.c <<'EOCP'
#include "dep.h"
EOCP
$cat >dep.h <<'EOCP'

EOCP
takeflags='flags=""
case "$@" in
	*--*)
		for arg
		do
			shift
			case "$arg" in
				--) break;;
				*) flags="$flags $arg";;
			esac
		done;;
esac'

case "$mkdep" in
	'')
	;;

	*)
		if test -x "$mkdep" &&
			$mkdep dep.c >dep.out 2>/dev/null &&
			$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
		then
			echo "$mkdep works."
		else
			mkdep=
		fi
esac

case "$mkdep" in
	'')
		$spitshell > ../mkdep <<EOM

$startsh
$takeflags
for srcfile
do
	$cpp -M -I. $cppflags \$flags \$srcfile 2>/dev/null
done
exit 0
EOM

		mkdep=$toplev/mkdep
		chmod +x $mkdep
		if $mkdep dep.c >dep.out 2>/dev/null &&
			$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
		then
			echo "Looks like we can use $cpp -M."
		else
			mkdep=
		fi
	;;
esac

case "$mkdep" in
	'')
		$spitshell > ../mkdep <<EOM
$startsh
$takeflags
for srcfile
do
	$cc -MM -I. $cppflags \$flags \$srcfile 2>/dev/null
done
exit 0
EOM
		mkdep=$toplev/mkdep
		chmod +x $mkdep
		if $mkdep dep.c >dep.out 2>/dev/null &&
			$contains "dep$_o: dep.h" dep.out >/dev/null 2>&1
		then
			echo "Looks like we can use $cc -MM."
		else
			mkdep=
		fi
	;;
esac

case "$mkdep" in
'')
	$spitshell >../mkdep <<EOS
$startsh
$takeflags
for srcfile
do
	case "\$srcfile" in
		*.c) c='.c';;
		*.y) c='.y';;
		*.l) c='.l';;
	esac

	filebase=\`basename \$srcfile \$c\`
	<\$srcfile $cpp $cppminus $cppflags -I. \$flags 2>/dev/null | \\
	$sed -e '/^# *[0-9]/!d' \\
		-e 's/^.*"\(.*\)".*\$/'\$filebase'$_o: \1/' \\
		-e 's|: \./|: |' \\
		-e 's|: *$|: '\$srcfile'|' | \\
	$grep -v '^#' | $sort | $uniq
done
exit 0
EOS
	mkdep=$toplev/mkdep
	chmod +x $mkdep
	if $mkdep dep.c >dep.out 2>/dev/null &&
		$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
	then
		echo "A shell script using $cpp does the trick."
	else
		echo "$cpp doesn't seem to be any use at all."
		$spitshell >../mkdep <<EOS
$startsh
$takeflags
files="\$@"
set X \$flags
shift
inc='.'
while test \$# -gt 0
do
	case "\$1" in
		-I) 
			shift
			inc="\$inc:\$1"
			;;
		-I*)
			dir=\`echo \$1 | sed -e 's/^-I//'\`
			inc="\$inc:\$dir"
		;;
	esac
	shift
done
set X \$files
shift
trap "$rm -f /tmp/mkdep\$\$; exit 1" 1 2 3 15
for srcfile
do
	case "\$srcfile" in
		*.c) c='.c';;
		*.y) c='.y';;
		*.l) c='.l';;
	esac
	filebase=\`basename \$srcfile \$c\`
	echo \$filebase$_o: \$srcfile
	$grep '^#[  ]*include' \$srcfile /dev/null | \
	$sed -n -e 's/#[   ]*include[  ]*//' \\
		-e '/<\(.*\)>/ d' \\
		-e 's/:[^"]*"\([^"]*\)".*/: \1/' \\
		-e "s/\\.c:/$_o:/p" > /tmp/mkdep\$\$
	IFS=': '
	while read file dep; do
		for dir in \$inc; do
			if $test -f "\$dir/\$dep"; then
				dep="\$dir/\$dep"
				break
			fi
		done
		echo "\$file: \$dep" | $sed -e 's,: \./,: ,'
	done </tmp/mkdep\$\$
	IFS=' '
	$rm -f /tmp/mkdep\$\$
done
exit 0
EOS
		mkdep=$toplev/mkdep
		chmod +x $mkdep
		if $mkdep dep.c >dep.out 2>/dev/null &&
			$contains "dep$_o:.*dep\.h" dep.out >/dev/null 2>&1
		then
			cat << EOM

I can use a script with grep instead, but it will make some incorrect
dependencies, since it doesn't understand about conditional compilation.
Moreover, some dependencies may be missing, because scanning won't be
a recursive process.
If you have a program which generates makefile dependencies, you may want
to use it.  If not, you can use the script and edit the Makefile by hand
if you need to.
EOM
		else
			mkdep=
			cat << EOM

I can't seem to generate makefile dependencies at all!  Perhaps you have a
program that does?  If you don't, you might look at the mkdep script to
see if you can create one which works.
EOM
		fi
	fi
esac

dflt="$mkdep"
fn=f~/
rp="Name of program to make makefile dependencies?"
. ./getfile
mkdep="$ans"
$rm -f dep.c dep.h dep$_o dep.out

: Cruising for prototypes
echo " "
echo "Checking out function prototypes..." >&4
$cat >prototype.c <<'EOCP'
main(int argc, char *argv[]) {
	exit(0);}
EOCP
if $cc $ccflags -c prototype.c >prototype.out 2>&1 ; then
	echo "Your C compiler appears to support function prototypes."
	val="$define"
else
	echo "Your C compiler doesn't seem to understand function prototypes."
	val="$undef"
fi
set prototype
eval $setvar
$rm -f prototype*

: see if signal is declared as pointer to function returning int or void
echo " "
xxx=`./findhdr signal.h`
$test "$xxx" && $cppstdin $cppminus $cppflags < $xxx >$$.tmp 2>/dev/null
if $contains 'int.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
elif $contains 'void.*\*[ 	]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have void (*signal())() instead of int." >&4
	val="$define"
elif $contains 'extern[ 	]*[(\*]*signal' $$.tmp >/dev/null 2>&1 ; then
	echo "You have int (*signal())() instead of void." >&4
	val="$undef"
else
	case "$d_voidsig" in
		'')
				echo "I can't determine whether signal handler returns void or int..." >&4
				dflt=void
				rp="What type does your signal handler return?"
				. ./myread
				case "$ans" in
					v*) 	val="$define";;
					*)	val="$undef";;
				esac;;

		"$define")
				echo "As you already told me, signal handler returns void." >&4;;

		*)
				echo "As you already told me, signal handler returns int." >&4;;
	esac
fi
set d_voidsig
eval $setvar
case "$d_voidsig" in
"$define") signal_t="void";;
*) signal_t="int";;
esac
$rm -f $$.tmp

: define an is-a-typedef? function
typedef='type=$1; var=$2; def=$3; shift; shift; shift; inclist=$@;

case "$inclist" in
	"")	 inclist="sys/types.h";;
esac;
eval "varval=\$$var";
case "$varval" in
	"")
		$rm -f temp.c;
		for inc in $inclist; do
		echo "#include <$inc>" >>temp.c;
		done;
		$cppstdin $cppflags $cppminus < temp.c >temp.E 2>/dev/null;
		if $contains $type temp.E >/dev/null 2>&1; then
			eval "$var=\$type";
		else
			eval "$var=\$def";
		fi;
		$rm -f temp.?;;

	*) 	eval "$var=\$varval";;
esac'

: see if time exists
echo " "
if set time val -f d_time; eval $csym; $val; then
	echo 'time() found.' >&4
	val="$define"
	set time_t timetype long stdio.h sys/types.h
	eval $typedef
	dflt="$timetype"
	echo " "
	rp="What type is returned by time() on this system?"
	. ./myread
	timetype="$ans"
else
	echo 'time() not found, hope that will do.' >&4
	val="$undef"
	timetype='int';
fi
set d_time
eval $setvar

: see if stdarg is available
echo " "
if $test `./findhdr stdarg.h`; then
	echo "<stdarg.h> found." >&4
	valstd="$define"
else
	echo "<stdarg.h> NOT found." >&4
	valstd="$undef"
fi

: see if varags is available
echo " "
if $test `./findhdr varargs.h`; then
	echo "<varargs.h> found." >&4
else
	echo "<varargs.h> NOT found, but that's ok (I hope)." >&4
fi

: set up the varargs testing programs
$cat > varargs.c <<EOP
#ifdef I_STDARG
#include <stdarg.h>
#endif
#ifdef I_VARARGS
#include <varargs.h>
#endif

#ifdef I_STDARG
int f(char *p, ...)
#else
int f(va_alist)
va_dcl
#endif
{
	va_list ap;
#ifndef I_STDARG
	char *p;
#endif
#ifdef I_STDARG
	va_start(ap,p);
#else
	va_start(ap);
	p = va_arg(ap, char *);
#endif
	va_end(ap);
}
EOP
$cat > varargs <<EOP
$startsh
if $cc -c $ccflags -D\$1 varargs.c >/dev/null 2>&1; then
	echo "true"
else
	echo "false"
fi
$rm -f varargs$_o
EOP
chmod +x varargs

: now check which varargs header should be included
echo " "
i_varhdr=''
case "$valstd" in
	"$define")
			if `./varargs I_STDARG`; then
				val='stdarg.h'
			elif `./varargs I_VARARGS`; then
				val='varargs.h'
		fi
		;;

	*)
		if `./varargs I_VARARGS`; then
			val='varargs.h'
		fi
	;;
esac

case "$val" in
	'')
			echo "I could not find the definition for va_dcl... You have problems..." >&4
			val="$undef"; set i_stdarg; eval $setvar
			val="$undef"; set i_varargs; eval $setvar
	;;

	*) 
			set i_varhdr
			eval $setvar
			case "$i_varhdr" in
				stdarg.h)
						val="$define"; set i_stdarg; eval $setvar
						val="$undef"; set i_varargs; eval $setvar
				;;

				varargs.h)
						val="$undef"; set i_stdarg; eval $setvar
						val="$define"; set i_varargs; eval $setvar
			;;
			esac
			echo "We'll include <$i_varhdr> to get va_dcl definition." >&4;;
esac
$rm -f varargs*

: see if prototypes support variable argument declarations
echo " "

case "$prototype$i_stdarg" in
	$define$define)
				echo "It appears we'll be able to prototype varargs functions." >&4
				val="$define"
	;;	

	*)
				echo "Too bad... We won't be using prototyped varargs functions..." >&4
				val="$undef"
	;;
esac

set vaproto
eval $setvar

$cat <<EOH

You may wish to compile with extra compiler warnings enabled.
Note that doing so enhances your chance of receiving your free set of steak
knives, particularly if you find any bugs and report them.
If you don't want extra warnings, answer "none".
  
EOH
case "$warnflags" in
	'') 	case "$cc" in
			*gcc*)
				dflt="-Wall -Wno-comment -Wfatal-errors"
				if $contains 'fprintf' `./findhdr stdio.h` >/dev/null 2>&1; then
					:
				else
					dflt="$dflt -Wno-implicit"
				fi
			;;

			*) 	dflt="none";;
		esac
	;;

	' ') 	dflt="none";;
*) dflt="$warnflags";;
esac

rp="Any $cc flags to enable warnings?"
. ./myread
case "$ans" in
	none)	warnflags=' ';;
	*)	 warnflags="$ans";;
esac

: define an alternate in-header-list? function
inhdr='echo " "; td=$define; tu=$undef; yyy=$@;
cont=true; xxf="echo \"<\$1> found.\" >&4";

case $# in 
	2)	 xxnf="echo \"<\$1> NOT found.\" >&4";;
	*)	 xxnf="echo \"<\$1> NOT found, ...\" >&4";;
esac;

case $# in
	4) 	instead=instead;;
	*) 	instead="at last";;
esac;

while $test "$cont"; do
	xxx=`./findhdr $1`
	var=$2; eval "was=\$$2";
	if $test "$xxx" && $test -r "$xxx";
	then
		eval $xxf;
		eval "case \"\$$var\" in $undef) . ./whoa; esac"; eval "$var=\$td";
		cont="";
	else
		eval $xxnf;
		eval "case \"\$$var\" in $define) . ./whoa; esac"; eval "$var=\$tu";
	fi;

	set $yyy; shift; shift; yyy=$@;
	case $# in
		0)	cont="";;
		2)	xxf="echo \"but I found <\$1> $instead.\" >&4";
			xxnf="echo \"and I did not find <\$1> either.\" >&4";;

		*)	xxf="echo \"but I found <\$1\> instead.\" >&4";
			xxnf="echo \"there is no <\$1>, ...\" >&4";;
	esac;
done;

while $test "$yyy";
do
	set $yyy; var=$2; eval "was=\$$2";
	eval "case \"\$$var\" in $define) . ./whoa; esac";
	eval "$var=\$tu";
	set $yyy; shift; shift; yyy=$@;
done'

: see if this is a sys/file.h system
val=''
set sys/file.h val
eval $inhdr

: do we need to include sys/file.h ?
case "$val" in
	"$define")
			echo " "
			if $h_sysfile; then
				val="$define"
				echo "We'll be including <sys/file.h>." >&4
			else
				val="$undef"
				echo "We won't be including <sys/file.h>." >&4
			fi
	;;

	*)
			h_sysfile=false
	;;
esac

set i_sysfile
eval $setvar

: see if fcntl.h is there
val=''
set fcntl.h val
eval $inhdr

: see if we can include fcntl.h
case "$val" in
	"$define")
			echo " "
			if $h_fcntl; then
			val="$define"
			echo "We'll be including <fcntl.h>." >&4
		else
			val="$undef"
			if $h_sysfile; then
				echo "We don't need to include <fcntl.h> if we include <sys/file.h>." >&4
			else
				echo "We won't be including <fcntl.h>." >&4
			fi
		fi
	;;

	*)
		h_fcntl=false
		val="$undef"
	;;
esac
set i_fcntl
eval $setvar

: see if stddef is available
set stddef.h i_stddef
eval $inhdr

: see if stdlib is available
set stdlib.h i_stdlib
eval $inhdr

: see if we should include time.h, sys/time.h, or both
echo " "
echo "Testing to see if we should include <time.h>, <sys/time.h> or both." >&4
$echo $n "I'm now running the test program...$c"

$cat >try.c <<'EOCP'
#include <sys/types.h>
#ifdef I_TIME
#include <time.h>
#endif /* I_TIME */

#ifdef I_SYSTIME
#ifdef SYSTIMEKERNEL
#define KERNEL
#endif /* SYSTIMEKERNEL*/
#include <sys/time.h>
#endif /* I_SYSTIME U*/

#ifdef I_SYSSELECT
#include <sys/select.h>
#endif /* I_SYSSELECT */ 
main()
{
	struct tm foo;
	#ifdef S_TIMEVAL
	struct timeval bar;
	#endif /* S_TIMEVAL */

	#ifdef S_TIMEZONE
	struct timezone tzp;
	#endif /* S_TIMEZONE */

	if (foo.tm_sec == foo.tm_sec)
		exit(0);

	#ifdef S_TIMEVAL
	if (bar.tv_sec == bar.tv_sec)
		exit(0);
	#endif /* S_TIMEVAL */

	exit(1);
}
EOCP

flags=''
s_timezone=''
sysselect=''
for s_timeval in '-DS_TIMEVAL' ''; do
for i_systimek in '' '-DSYSTIMEKERNEL'; do
	for i_time in '' '-DI_TIME'; do
		for i_systime in '-DI_SYSTIME' ''; do
			case "$flags" in
				'')		$echo $n ".$c"
							if $cc $ccflags                                                     \
							   $i_time $i_systime $i_systimek $sysselect $s_timeval $s_timezone \
							   try.c -o try >/dev/null 2>&1 ;
							   then
								set X $i_time $i_systime $i_systimek $sysselect $s_timeval
								shift
								flags="$*"
								echo " "
								$echo $n "Succeeded with $flags$c"
							fi
						;;
			esac
		done
	done
done
done
timeincl=''
echo " "

case "$flags" in
	*SYSTIMEKERNEL*) 	i_systimek="$define"
				timeincl=`./findhdr sys/time.h`
				echo "We'll include <sys/time.h> with KERNEL defined." >&4;;

	*)			i_systimek="$undef";;
esac

case "$flags" in
	*I_TIME*)	i_time="$define"
			timeincl=`./findhdr time.h`" $timeincl"
			echo "We'll include <time.h>." >&4;;

	*)		i_time="$undef";;
esac

case "$flags" in
	*I_SYSTIME*)	i_systime="$define"
			timeincl=`./findhdr sys/time.h`" $timeincl"
			echo "We'll include <sys/time.h>." >&4;;

	*)		i_systime="$undef";;
esac

$rm -f try.c try

: see if sys/types.h has to be included
set sys/types.h i_systypes
eval $inhdr

: see if this is a unistd.h system
set unistd.h i_unistd
eval $inhdr

: end of configuration questions
echo " "
echo "End of configuration questions."
echo " "

: back to where it started
if test -d ../UU; then
	cd ..
fi

: configuration may be patched via a 'config.over' file
if $test -f config.over; then
	echo " "
	dflt=y
	rp='I see a config.over file.  Do you wish to load it?'
	. UU/myread

	case "$ans" in
		n*)	echo "OK, I'll ignore it.";;

		*)	. ./config.over
			echo "Configuration override changes have been loaded."
			;;
	esac
fi

: in case they want portability, strip down executable paths
case "$d_portable" in
	"$define")
			echo " "
			echo "Stripping down executable paths..." >&4
			for file in $loclist $trylist; do
				eval $file="\$file"
			done
	;;
esac

: create config.sh file
echo " "
echo "Creating config.sh..." >&4
$spitshell <<EOT >config.sh
$startsh
#
# This file was produced by running the Configure script. It holds all the
# definitions figured out by Configure. Should you modify one of these values,
# do not forget to propagate your changes by running "Configure -der". You may
# instead choose to run each of the .sh files by yourself, or "Configure -S".
#

# Package name      : $package
# Source directory  : $src
# Configuration time: $cf_time
# Configured by     : $cf_by
# Target system     : $myuname

Author='$Author'
Date='$Date'
Header='$Header'
Id='$Id'
Locker='$Locker'
Log='$Log'
Mcc='$Mcc'
RCSfile='$RCSfile'
Revision='$Revision'
Source='$Source'
State='$State'
afs='$afs'
ar='$ar'
archobjs='$archobjs'
awk='$awk'
bash='$bash'
bin='$bin'
binexp='$binexp'
bison='$bison'
byacc='$byacc'
c='$c'
cat='$cat'
cc='$cc'
ccflags='$ccflags'
cf_by='$cf_by'
cf_time='$cf_time'
chgrp='$chgrp'
chmod='$chmod'
chown='$chown'
comm='$comm'
compress='$compress'
contains='$contains'
cp='$cp'
cpio='$cpio'
cpp='$cpp'
cppfilecom='$cppfilecom'
cppflags='$cppflags'
cpplast='$cpplast'
cppminus='$cppminus'
cpprun='$cpprun'
cppstdin='$cppstdin'
cppstdinflags='$cppstdinflags'
csh='$csh'
d_access='$d_access'
d_attribut='$d_attribut'
d_bsd='$d_bsd'
d_const='$d_const'
d_cppcanstdin='$d_cppcanstdin'
d_cppignhdrs='$d_cppignhdrs'
d_flexfnam='$d_flexfnam'
d_gnulibc='$d_gnulibc'
d_index='$d_index'
d_link='$d_link'
d_open3='$d_open3'
d_portable='$d_portable'
d_strchr='$d_strchr'
d_strftime='$d_strftime'
d_strstr='$d_strstr'
d_symlink='$d_symlink'
d_time='$d_time'
d_voidsig='$d_voidsig'
d_volatile='$d_volatile'
d_xenix='$d_xenix'
date='$date'
defvoidused='$defvoidused'
echo='$echo'
egrep='$egrep'
emacs='$emacs'
expr='$expr'
find='$find'
firstmakefile='$firstmakefile'
flex='$flex'
gcc='$gcc'
gccversion='$gccversion'
glibpth='$glibpth'
grep='$grep'
gzip='$gzip'
h_fcntl='$h_fcntl'
h_sysfile='$h_sysfile'
hint='$hint'
i_fcntl='$i_fcntl'
i_stdarg='$i_stdarg'
i_stddef='$i_stddef'
i_stdlib='$i_stdlib'
i_string='$i_string'
i_sysfile='$i_sysfile'
i_systime='$i_systime'
i_systimek='$i_systimek'
i_systypes='$i_systypes'
i_time='$i_time'
i_unistd='$i_unistd'
i_varargs='$i_varargs'
i_varhdr='$i_varhdr'
incpath='$incpath'
inews='$inews'
installbin='$installbin'
installmansrc='$installmansrc'
installprivlib='$installprivlib'
ksh='$ksh'
ldflags='$ldflags'
less='$less'
lex='$lex'
lexflags='$lexflags'
libc='$libc'
libpth='$libpth'
libs='$libs'
libyacc='$libyacc'
line='$line'
lint='$lint'
lkflags='$lkflags'
ln='$ln'
lns='$lns'
locincpth='$locincpth'
loclibpth='$loclibpth'
lp='$lp'
lpr='$lpr'
ls='$ls'
mail='$mail'
mailx='$mailx'
make='$make'
manext='$manext'
mansrc='$mansrc'
mansrcexp='$mansrcexp'
mips='$mips'
mips_type='$mips_type'
mkdep='$mkdep'
mkdir='$mkdir'
more='$more'
mv='$mv'
myuname='$myuname'
n='$n'
nm_opt='$nm_opt'
nm_so_opt='$nm_so_opt'
nroff='$nroff'
optimize='$optimize'
osname='$osname'
osvers='$osvers'
package='$package'
perl='$perl'
pg='$pg'
plibpth='$plibpth'
pmake='$pmake'
pr='$pr'
prefix='$prefix'
prefixexp='$prefixexp'
privlib='$privlib'
privlibexp='$privlibexp'
prototype='$prototype'
rm='$rm'
rmail='$rmail'
runnm='$runnm'
sed='$sed'
sendmail='$sendmail'
sh='$sh'
shar='$shar'
sharpbang='$sharpbang'
shsharp='$shsharp'
signal_t='$signal_t'
sleep='$sleep'
smail='$smail'
so='$so'
sort='$sort'
spackage='$spackage'
spitshell='$spitshell'
src='$src'
startsh='$startsh'
strings='$strings'
submit='$submit'
sysman='$sysman'
tail='$tail'
tar='$tar'
tbl='$tbl'
test='$test'
timeincl='$timeincl'
timetype='$timetype'
touch='$touch'
tr='$tr'
troff='$troff'
uname='$uname'
uniq='$uniq'
usenm='$usenm'
usrinc='$usrinc'
uuname='$uuname'
vaproto='$vaproto'
vi='$vi'
voidflags='$voidflags'
warnflags='$warnflags'
xlibpth='$xlibpth'
yacc='$yacc'
yaccflags='$yaccflags'
zcat='$zcat'
zip='$zip'
EOT

: add special variables
$test -f $src/patchlevel.h && \
awk '/^#define/ {printf "%s=%s\n",$2,$3}' $src/patchlevel.h >>config.sh
echo "CONFIG=true" >>config.sh

: propagate old symbols
if $test -f UU/config.sh; then
	<UU/config.sh sort | uniq >UU/oldconfig.sh
	sed -n 's/^\([a-zA-Z_0-9]*\)=.*/\1/p' config.sh config.sh UU/oldconfig.sh |\
	sort | uniq -u >UU/oldsyms
	set X `cat UU/oldsyms`
	shift
	case $# in
		0) ;;

		*)
			cat <<EOM

Hmm...You had some extra variables I don't know about...I'll try to keep 'em...
EOM

			echo "# Variables propagated from previous config.sh file." >>config.sh
			for sym in `cat UU/oldsyms`; do
				echo "    Propagating $hint variable "'$'"$sym..."
				eval 'tmp="$'"${sym}"'"'
				echo "$tmp" | sed -e "s/'/'\"'\"'/g" -e "s/^/$sym='/" -e "s/$/'/" >>config.sh
			done
		;;
	esac
fi

: Finish up by extracting the .sh files
case "$alldone" in
	exit)
		$rm -rf UU
		echo "Done."
		exit 0
	;;

	cont)
	;;

	'')
		dflt=''
		nostick=true
		$cat <<EOM

If you'd like to make any changes to the config.sh file before I begin
to configure things, do it as a shell escape now (e.g. !vi config.sh).

EOM
		rp="Press return or use a shell escape to edit config.sh:"
		. UU/myread
		nostick=''

		case "$ans" in
			'')	 ;;

			*) : 	in case they cannot read
				sh 1>&4 -c "$ans";;
		esac
	;;
esac

: if this fails, just run all the .sh files by hand
. ./config.sh >& /dev/null

echo " "
exec 1>&4
. ./UU/extract

if $contains '^depend:' [Mm]akefile >/dev/null 2>&1; then
	dflt=y
	case "$silent" in
		true)	;;

		*)
		$cat <<EOM

Now you need to generate make dependencies by running "make depend".
You might prefer to run it in background: "make depend > makedepend.out &"
It can take a while, so you might not want to run it right now.

EOM
		;;
	esac
	rp="Run make depend now?"
	. UU/myread
	case "$ans" in
		y*)
			make depend && echo "Now you must run a make."
			;;
		*)
			echo "You must run 'make depend' then 'make'."
			;;
	esac
elif test -f [Mm]akefile; then
	echo " "
	echo "Now you must run a make."
else
	echo "Done."
fi

$rm -f kit*isdone ark*isdone
$rm -rf UU

: End of Configure

